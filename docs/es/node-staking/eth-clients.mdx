import ethereum_client_diversity from "./images/ethereum-client-diversity-aug-2025.png";

# Selección de sus Clientes ETH

El instalador de Smartnode de Rocket Pool puede transformar su máquina en un nodo Ethereum completo, ya que requiere tanto clientes de Ejecución como de Consenso para funcionar correctamente.

Los términos ETH1/ETH2 han sido desaprobados.
Las cadenas se referirán como la **Capa de Ejecución (ETH1)** y la **Cadena Beacon o Capa de Consenso (ETH2)** en el resto de estas guías.

Si ya tiene clientes de Ejecución y Consenso ejecutándose en una máquina separada (por ejemplo, si ya está haciendo staking en solitario), entonces omita esta sección y pase a la sección [Configuración de un Nodo Rocket Pool Híbrido con Clientes Externos](./install-modes#la-configuración-híbrida-con-clientes-externos).

De lo contrario, continúe leyendo para obtener más información sobre sus opciones para los clientes de Ejecución y Consenso.

::: warning NOTA
A partir de agosto de 2025, la distribución de clientes en la Cadena Beacon se ve aproximadamente así:

<img src={ethereum_client_diversity} width="100%" height="auto" />

_Datos obtenidos de [https://clientdiversity.org](https://clientdiversity.org)_

Obtener datos sobre qué cliente de consenso está ejecutando un validador es un problema relativamente difícil porque los clientes no se identifican fácilmente. La página [metodología de datos](https://clientdiversity.org/methodology/)
en [https://clientdiversity.org](https://clientdiversity.org) explica cómo se obtienen los datos de diferentes fuentes. Siéntase libre de consultar
[https://ethernodes.org/](https://ethernodes.org/) como una fuente adicional de datos.

La abrumadora mayoría de los operadores de nodos actualmente utilizan Geth como Cliente de Ejecución y Lighthouse o Prysm como Cliente de Consenso.
En interés de apoyar la salud de la Capa de Ejecución (anteriormente ETH1) y la Cadena Beacon (anteriormente ETH2), actualmente recomendamos que considere usar clientes diferentes.
Aquí hay algunos artículos relevantes sobre por qué una diversidad de clientes uniforme es crucial para la salud de la red si desea obtener más información:

[https://clientdiversity.org/#why](https://clientdiversity.org/#why)

[https://blog.ethereum.org/2020/08/21/validated-why-client-diversity-matters/](https://blog.ethereum.org/2020/08/21/validated-why-client-diversity-matters/)

[https://our.status.im/the-importance-of-client-diversity/](https://our.status.im/the-importance-of-client-diversity/)

[https://medium.com/prysmatic-labs/eth2-mainnet-incident-retrospective-f0338814340c](https://medium.com/prysmatic-labs/eth2-mainnet-incident-retrospective-f0338814340c)

[https://dankradfeist.de/ethereum/2022/03/24/run-the-majority-client-at-your-own-peril.html](https://dankradfeist.de/ethereum/2022/03/24/run-the-majority-client-at-your-own-peril.html)

[https://eth2book.info/bellatrix/part2/incentives/diversity](https://eth2book.info/bellatrix/part2/incentives/diversity/)
:::

Para usuarios que desean ponerse en marcha rápidamente, el instalador de Smartnode proporciona una opción de `Cliente Aleatorio` que puede ser la mejor opción.
Para usuarios que tienen en mente un cliente específico que les gustaría usar, proporcionamos la capacidad de elegir uno fácilmente durante la instalación de Rocket Pool.
Las opciones a continuación ayudan a describir cada cliente para que pueda tomar una decisión informada si desea especificar cuál desea.

## Clientes de Ejecución

Rocket Pool admite cuatro clientes de Ejecución diferentes: **Geth**, **Besu**, **Nethermind** y **Reth**.

Ejecutar un cliente de Ejecución implica almacenar una copia de la blockchain de la capa de Ejecución en su máquina.
Interactúa a través de comunicaciones peer-to-peer con otros nodos EC para registrar y verificar nuevos bloques y transacciones.
Un cliente de Ejecución completo es **requerido** para ejecutar un validador ahora que las capas de Ejecución y Consenso se han fusionado.

### Geth

[Geth](https://geth.ethereum.org/) (formalmente llamado `Go Ethereum`) es una de las tres implementaciones originales (junto con C++ y Python) del protocolo Ethereum.
Está escrito en Go, es completamente de código abierto y tiene licencia GNU LGPL v3.

Geth es el Cliente de Ejecución más antiguo y más utilizado en todo el mundo.
Tiene una reputación de ser muy estable y confiable.

Es multihilo, lo que significa que puede aprovechar toda su CPU.
Su uso de RAM es configurable, hasta un **mínimo de aproximadamente 4 GB para Mainnet**.
Esto lo hace viable tanto para sistemas de baja potencia como para sistemas de alta potencia.

::: warning NOTA
Geth requiere **poda offline** de su base de datos periódicamente: su base de datos crecerá con el tiempo y consumirá gradualmente todo su espacio libre en disco a menos que la pode cuando su disco se quede sin espacio libre.
La frecuencia con la que necesita podar dependerá del tamaño de su SSD.

Para obtener más información sobre cómo podar Geth, consulte la página [Poda del Cliente de Ejecución](./pruning).
:::

### Besu

Hyperledger [Besu](https://besu.hyperledger.org/en/stable/) es un cliente Ethereum de código abierto desarrollado bajo la licencia Apache 2.0 y escrito en [Java](https://en.wikipedia.org/wiki/Java_%28programming_language%29).
Las características más emocionantes de Besu es su uso de [Bonsai Tries](https://consensys.net/blog/news/bonsai-tries-a-big-update-for-small-state-storage-in-hyperledger-besu/) para el almacenamiento de estado. Además de sus mejores características de rendimiento, Bonsai Tries le dan a Besu dos ventajas interesantes sobre los otros clientes:

1. Besu _no_ necesita podarse en absoluto; es efectivamente libre de mantenimiento en ese aspecto
2. Besu puede revisar cualquier bloque pasado en la blockchain, aunque hace esto rebobinando cada bloque, por lo que alcanzar bloques de hace mucho tiempo puede tomar algo de tiempo.

Besu actualmente recomienda al menos **16 GB de RAM**, aunque es posible ejecutarse con éxito con 8 GB.

### Nethermind

[Nethermind](https://nethermind.io/nethermind-client/) está escrito en [.NET Core](https://en.wikipedia.org/wiki/.NET).
Presume de la velocidad de sincronización más rápida de los clientes de Ejecución y tiene un rico conjunto de opciones de configuración.
Está diseñado pensando en los operadores de nodos y tiene muchas características que encontrarán útiles.

Al igual que Geth, Nethermind requiere poda periódica de su base de datos.
Sin embargo, a diferencia de Geth, la base de datos de Nethermind [puede podarse mientras permanece en línea](https://medium.com/nethermind-eth/netherminds-full-pruning-is-here-cutting-the-gordian-knot-5e3450f02de9).
Esto significa que no necesita apagar su cliente y depender de un respaldo para podar.
Sin embargo, el proceso de poda en línea de Nethermind consume muchos recursos, por lo que los usuarios que ejecutan nodos de baja potencia pueden ver cierta degradación del rendimiento durante el proceso.

Nethermind requiere **al menos 16GB de RAM**, aunque más es preferible.

::: tip NOTA
Nethermind requiere poda periódica de su base de datos periódicamente: su base de datos crecerá con el tiempo y consumirá gradualmente todo su espacio libre en disco a menos que la pode cuando su disco se quede sin espacio libre.
La frecuencia con la que necesita podar dependerá del tamaño de su SSD.

Sin embargo, a diferencia de Geth, Nethermind **permanece en línea** mientras está podando.
Esto lo convierte en una opción convincente para nodos porque no tendrán tiempo de inactividad durante la poda.

Para obtener más información sobre cómo podar Nethermind, consulte la página [Poda del Cliente de Ejecución](./pruning).
:::

### Reth

[Reth](https://reth.rs/) es un cliente de capa de Ejecución escrito en [Rust](https://www.rust-lang.org/) y utiliza la arquitectura [Erigon staged-sync](https://erigon.substack.com/p/erigon-stage-sync-and-control-flows).
Reth está diseñado desde cero con eficiencia, rendimiento y modularidad en mente. Está licenciado bajo la licencia permisiva Apache/MIT y construido
con paquetes pequeños, bien abstraídos, bien probados y evaluados. Esto hace una gran experiencia de desarrollador de código abierto y permite que los componentes de Reth se utilicen en otros proyectos.

Como el cliente más nuevo en el ecosistema, Reth está evolucionando rápidamente y ganando adopción. Si bien los requisitos de RAM y CPU son flexibles, el requisito más importante
es, con mucho, el disco. Sugerimos usar un buen [disco TLC](https://gist.github.com/yorickdowne/f3a3e79a573bf35767cd002cc977b038).
Reth requiere **al menos 8 GB de RAM** para un nodo completo o **16 GB de RAM** para un nodo de archivo.

### Tabla Comparativa de Clientes

| Cliente    | Tipo     | Uso de CPU | Uso Mínimo de RAM | Tiempo de Sincronización |
| ---------- | -------- | ---------- | ----------------- | ------------------------ |
| Geth       | Completo | Moderado   | 4 GB              | Moderado                 |
| Besu       | Completo | Moderado   | 6 GB              | Lento                    |
| Nethermind | Completo | Moderado   | 16 GB             | Rápido                   |
| Reth       | Completo | Moderado   | 8 GB              | Rápido                   |

## Clientes de Consenso

El instalador de Rocket Pool se enorgullece de admitir cinco clientes de Consenso disponibles actualmente: **Lighthouse**, **Lodestar**, **Nimbus**, **Prysm** y **Teku**.

Cada uno de estos es un **cliente completo**, lo que significa que contribuirá a la descentralización de la red de Consenso independientemente del cliente que elija.

Los cinco clientes son de bajo riesgo, bajo mantenimiento y generarán recompensas totales prácticamente idénticas de la validación.
Difieren ligeramente en términos de requisitos de recursos y características, pero no puede equivocarse con ninguno de ellos.

De forma predeterminada, el instalador de Rocket Pool ofrecerá seleccionar un cliente de consenso aleatorio para usted.
Esto ayudará a contribuir a la **diversidad general de la red**.
Esto es importante desde una perspectiva de seguridad: si un cliente es utilizado por la mayoría de los nodos y sufre un error o ataque grave, podría hacer que todos esos nodos fallen y, por lo tanto, amenazar la estabilidad de toda la Cadena Beacon.

### Lighthouse

[Lighthouse](https://lighthouse.sigmaprime.io/) es un cliente Ethereum 2.0 de código abierto mantenido por [Sigma Prime](https://sigmaprime.io/).
Implementa la [especificación Ethereum 2.0](https://github.com/ethereum/consensus-specs) según lo definido por el equipo de Investigación de la Fundación Ethereum.

Lighthouse es un proyecto de sistemas distribuidos de vanguardia que implementa tecnologías en la vanguardia de la investigación blockchain; incluyendo consenso proof-of-stake, ejecución de transacciones en paralelo y separación de estado (sharding).

Lighthouse no tiene afiliación oficial con la Fundación Ethereum y continuará siguiendo su orientación siempre que permanezca en el mejor interés del protocolo Ethereum y la comunidad que lo rodea.

Lighthouse está implementado en [Rust](https://www.rust-lang.org/) y mantendrá un enfoque en seguridad y eficiencia.

### Lodestar

[Lodestar](https://lodestar.chainsafe.io/) es el quinto cliente de consenso Ethereum de código abierto mantenido por [ChainSafe Systems](https://chainsafe.io/). Nuestro producto estrella es nuestro cliente beacon chain y validador con capacidad de producción para el consenso de Ethereum. Nuestro software y herramientas están ubicados de manera única como la opción ideal para investigadores y desarrolladores para la creación rápida de prototipos y el uso en navegadores. Millones de desarrolladores en todo el mundo están familiarizados con Typescript, y las bases de código de alta calidad de Lodestar son excelentes introducciones al mundo de Ethereum.

Lodestar también ha sido líder en investigación, estandarización e implementación de clientes ligeros de Ethereum. Nos esforzamos por trabajar con otros implementadores de clientes, investigadores y desarrolladores para demostrar la importancia de que los navegadores utilicen datos sin confianza directamente de la blockchain.

El nicho de Lodestar está en su lenguaje de implementación, [Typescript](https://www.typescriptlang.org/).

### Nimbus

[Nimbus](https://nimbus.team/) es una implementación de cliente tanto para Ethereum 2.0 como para Ethereum 1.0 que se esfuerza por ser lo más liviano posible en términos de recursos utilizados.
Esto le permite funcionar bien en sistemas embebidos y dispositivos con recursos restringidos.

Sin embargo, el hardware con recursos restringidos no es lo único para lo que Nimbus es bueno.
Su bajo consumo de recursos hace que sea fácil ejecutar Nimbus junto con otras cargas de trabajo en su servidor (esto es especialmente valioso para los stakers que buscan reducir el costo de sus instancias de servidor).

Nimbus está escrito en [Nim](https://nim-lang.org/) y mantenido por el [equipo Status.im](https://status.im/about/).

### Prysm

El proyecto [Prysm](https://docs.prylabs.network/docs/getting-started/#what-is-prysm) es una implementación completa para la red Ethereum 2.0 escrita completamente en el [lenguaje de programación Go](https://golang.org/).

Creado por [Prysmatic Labs](https://prysmaticlabs.com/), Prysm implementa la [especificación oficial Ethereum 2.0](https://github.com/ethereum/consensus-specs), que es el producto de un esfuerzo colectivo continuo de investigación y desarrollo de varios equipos en todo el ecosistema de Ethereum, incluida la [Fundación Ethereum](https://ethereum.org/).

### Teku

[Teku](https://docs.teku.consensys.net/en/stable/) (anteriormente conocido como Artemis) es un cliente de consenso Ethereum basado en [Java](https://en.wikipedia.org/wiki/Java_%28programming_language%29) diseñado y construido para satisfacer las necesidades institucionales y los requisitos de seguridad.
PegaSys es un brazo de [ConsenSys](https://consensys.net/) dedicado a construir clientes y herramientas de grado empresarial para interactuar con la plataforma central de Ethereum.

Teku tiene licencia Apache 2.0 y está escrito en Java, un lenguaje notable por su madurez y ubicuidad.

### Tabla Comparativa de Clientes

| Cliente    | Uso de CPU | Uso Mínimo de RAM | Tiempo de Sincronización                  |
| ---------- | ---------- | ----------------- | ----------------------------------------- |
| Lighthouse | Moderado   | 2 GB              | Instantáneo con sincronización checkpoint |
| Lodestar   | Moderado   | 4 GB              | Instantáneo con sincronización checkpoint |
| Nimbus     | Bajo       | 0.75 GB           | Instantáneo con sincronización checkpoint |
| Prysm      | Moderado   | 2 GB              | Instantáneo con sincronización checkpoint |
| Teku       | Moderado   | 4 GB              | Instantáneo con sincronización checkpoint |
