import { Tab, Tabs } from "@rspress/core/theme";
import ECSelection from "./images/tui-ec-selection.png";
import tuiExternalEC from "./images/tui-external-ec.png";
import tuiLocalCC from "./images/tui-local-cc.png";
import tuiLocalGraffiti from "./images/tui-local-graffiti.png";
import tuiLocalCheckpoint from "./images/tui-local-checkpoint.png";
import tuiLocalDD from "./images/tui-local-dd.png";
import tuiExternalLH from "./images/tui-external-lh.png";
import tuiExternalGraffiti from "./images/tui-external-graffiti.png";
import tuiExternalDD from "./images/tui-external-dd.png";
import tuiExternalPrysm from "./images/tui-external-prysm.png";
import tuiExternalTeku from "./images/tui-external-teku.png";

# Configurando a Stack do Smartnode (Docker / Modo Híbrido)

Executar clientes completos de camada de Execução e camada de Consenso pode ser intimidante; existem várias opções para escolher e cada uma delas possui uma infinidade de configurações diferentes.
Felizmente, o Smartnode foi projetado para ocultar toda essa complexidade, tornando-o rápido e fácil de configurar, enquanto ainda oferece a liberdade de personalizar tudo, se assim desejar.

Nesta seção, abordaremos os vários métodos para configurar o Smartnode se você estiver usando a **configuração baseada em Docker** ou uma **configuração Híbrida**, onde você se conecta a clientes de Execução ou Consenso gerenciados externamente (por exemplo, clientes que você gerencia fora do Smartnode para staking solo).

::: warning NOTA
Se você estiver usando o modo Nativo sem Docker, visite o [guia de configuração Nativa](./config-native) em vez disso.
:::

Existem três maneiras de configurá-lo:

- Via [Interface do Assistente](#configurando-via-assistente) - esta é a maneira mais fácil. Ele só faz algumas perguntas básicas e usa padrões bem testados para o resto. Isso será o que você verá quando executar `rocketpool service config` pela primeira vez.
- Via [Interface do Gerenciador de Configurações](#configurando-via-gerenciador-de-configuracoes) - isso oferece acesso a todas as configurações do Smartnode para que você possa personalizar tudo o quanto quiser.
- Sem interface via [Linha de Comando](#configurando-via-linha-de-comando) - esta é uma opção para pessoas que executam o Smartnode em um ambiente sem interface (não interativo) e precisam configurá-lo automaticamente.

Escolha qual modo você gostaria de aprender mais na lista acima, ou simplesmente percorra cada opção abaixo.

## Configurando via Assistente

Para iniciar o processo de configuração, execute o seguinte comando:

```shell
rocketpool service config
```

Isso iniciará uma interface baseada em terminal que permitirá configurar seu node de forma rápida e fácil, além de fornecer controle opcional refinado sobre cada configuração para personalização avançada.

::: tip NOTA
Se você já configurou o Smartnode, em vez disso, você será recebido com o [Gerenciador de Configurações](#configurando-a-stack-do-smartnode-via-gerenciador-de-configuracoes).
Você pode optar por reabrir o Assistente de lá, se preferir, e todas as suas configurações existentes serão pré-selecionadas para você.
:::

Quando você executar a interface de configuração pela primeira vez (ou se optar por executar o Assistente novamente mais tarde), você será apresentado a uma tela que se parece com esta:

<img src="./images/tui-first-time.png" width="100%" height="auto" />

::: tip DICA
Para usar o Assistente, **pressione as `Setas` (cima/baixo/esquerda/direita) para navegar entre coisas como botões (escolhas) ou caixas de texto**.
Você também pode usar `Tab` e `Shift+Tab` se preferir - fará a mesma coisa.

Para botões, **o que está selecionado atualmente será destacado em verde**.
Os que estão em preto não estão selecionados.
Na captura de tela acima, `Next` está atualmente selecionado e `Quit` não está.

**Pressione `Enter` ou `Espaço` para selecionar um botão**, análogo a clicar nele com o mouse.

**Pressione `Escape` para voltar ao diálogo anterior** se você mudou de ideia sobre algo.
Isso será útil à medida que você avança pelas várias páginas do Assistente.

**Mantenha `Ctrl` pressionado e pressione `C` a qualquer momento para sair do Assistente sem salvar nada**.

Por exemplo, na tela acima, você poderia pressionar as setas `esquerda` e `direita` para se mover entre os botões `Next` e `Quit`.

Pressionar `Enter` enquanto `Next` está selecionado prosseguirá para a próxima tela.
Pressionar `Enter` enquanto `Quit` está selecionado sairá do Assistente sem salvar.
:::

Quando estiver pronto para começar, pressione `Next`.

### Escolhendo uma Rede

Na próxima tela, você será solicitado a escolher qual rede deseja usar:

<img src="./images/tui-network.png" width="100%" height="auto" />

Você pode destacar as diferentes escolhas com as setas `Cima` e `Baixo` (ou `Tab` e `Shift+Tab`).
Quando você mudar de escolha, a caixa de **Descrição** à direita mostrará uma breve descrição de cada opção.
Isso é verdade para todas as páginas baseadas em escolha no Assistente, não apenas na seleção de rede, então você verá esse estilo de página com frequência.

Se você quiser praticar executando um node Rocket Pool na rede de testes Hoodi com ETH e RPL falsos que você pode obter gratuitamente, selecione **Hoodi Testnet**.

Se você estiver pronto para criar um node Rocket Pool real na Mainnet para ganhar recompensas reais, selecione **Mainnet**.

### Modo de Cliente

Você será apresentado com duas opções para modo de cliente:

<img src="./images/tui-client-mode.png" width="100%" height="auto" />

**Gerenciado Localmente** (também conhecido como **"Modo Docker"**) é a escolha padrão.
Use-o se você ainda não tiver um par de clientes e quiser que o Smartnode gerencie um para você.
Ao escolher isso, o Smartnode criará, configurará e gerenciará um par de cliente de Execução e Consenso como contêineres Docker.
Não se preocupe, você poderá escolher _qual_ cliente deseja executar em seguida.

**Gerenciado Externamente** (também conhecido como **"Modo Híbrido"**) é uma escolha conveniente para usuários que já têm um par de cliente de Execução e Consenso em execução em outro lugar que eles gerenciam manualmente.
Ao escolher isso, o Smartnode simplesmente se conectará aos seus clientes existentes e não executará um próprio.
Por exemplo, os usuários podem usar isso para se conectar aos clientes que atualmente usam para staking solo; dessa forma, eles não precisam ter duas cópias separadas dos clientes.

:::warning NOTA
Desde a Fusão da camada de Execução-Consenso, você _não pode_ misturar e combinar esses modos (por exemplo, você não pode ter um cliente de Execução local, mas um cliente de Consenso gerenciado externamente).
Você deve escolher tudo gerenciado localmente ou tudo gerenciado externamente.
:::

### Configuração do Cliente de Execução

Escolha qual modo você gostaria de usar para gerenciar seu cliente de Execução e siga as etapas na aba correspondente abaixo:

<div className="p-3">
  <Tabs>
    <Tab label="Gerenciado Localmente">
      Se você quiser que o Smartnode gerencie um cliente de Execução para você, a próxima tela pedirá que você escolha um cliente:

      <img src={ECSelection} width="100%" height="auto"/>

      Consulte a seção [Escolhendo seus clientes ETH](/pt/node-staking/eth-clients#execution-clients) para uma descrição de cada opção.
      Depois de fazer sua escolha, clique na aba apropriada abaixo para aprender como configurá-lo:

      Se você escolher **Geth**, **Besu** ou **Nethermind**, o Assistente cuidará de toda a configuração para você.
      Você pode ajustar manualmente alguns de seus parâmetros no final deste processo, mas os padrões que ele usa são completamente apropriados para operação de node.
      Você pode prosseguir para a próxima seção.


      <p className="rspress-directive warning">
        <p className="rspress-directive-title">NOTA</p>
        **Abra a porta P2P na configuração de encaminhamento de porta do seu roteador**. Configure-o para encaminhar a **porta 30303** em TCP e UDP para o endereço IP local da sua máquina.
        Dessa forma, outros clientes de Consenso podem descobri-lo e se comunicar com ele de fora. Isso ajudará seu cliente de Consenso a sincronizar rapidamente e melhorar o desempenho (e, portanto, as recompensas).

        Cada roteador tem uma maneira diferente de fazer isso, então **você precisará verificar o manual do seu roteador sobre como configurar o encaminhamento de porta**.
      </p>

      <p className="rspress-directive warning">
        <p className="rspress-directive-title">NOTA</p>
        Como o Smartnode será executado em seu próprio contêiner Docker, ele usará a rede interna do Docker.
        Você não poderá usar nomes de host como `localhost` ou `127.0.0.1` aqui; se o seu cliente de Execução estiver rodando na mesma máquina que o Smartnode, você precisará fornecer o endereço IP LAN da máquina.
      </p>

      E com isso, seu cliente de Execução está totalmente configurado!
    </Tab>
    <Tab label="Externo">
      Para um cliente de Execução gerenciado externamente, a próxima tela solicitará as URLs de sua API RPC (web3) baseada em HTTP e de sua API RPC baseada em Websocket:

      <img src={tuiExternalEC} width="100%" height="auto"/>

      O Smartnode usará a URL HTTP para se comunicar com ele e executar atividades de blockchain, como consultar o estado da cadeia e enviar transações.
      **Se você ainda não tiver a porta da API do seu cliente habilitada e acessível a partir da sua máquina Smartnode, você precisará configurá-la agora.**
      As instruções sobre isso variam de cliente para cliente; consulte a documentação do seu cliente para aprender como configurar o endpoint HTTP RPC.

      A URL do Websocket só é relevante se você precisar dela para seu próprio uso; o Smartnode não a utiliza.
      Você pode deixá-la em branco se não precisar dela.

      <p className="rspress-directive warning">
        <p className="rspress-directive-title">NOTA</p>
        Como o Smartnode será executado em seu próprio contêiner Docker, ele usará a rede interna do Docker.
        Você não poderá usar nomes de host como `localhost` ou `127.0.0.1` aqui; se o seu cliente de Execução alternativo estiver rodando na mesma máquina que o Smartnode, você precisará fornecer o endereço IP LAN da máquina.
      </p>

      Quando estiver satisfeito com suas escolhas de cliente de Execução alternativo, prossiga para a próxima etapa.
    </Tab>

  </Tabs>
</div>

### Configuração do Cliente de Consenso

Agora que você tem um cliente de Execução pronto, a próxima tarefa é configurar o cliente de Consenso.
O "modo" (local ou externo) será herdado da escolha que você usou para seu cliente de Execução anteriormente.

Escolha qual modo você selecionou anteriormente nas abas abaixo:

<div className="p-3">
  <Tabs>
    <Tab label="Gerenciado Localmente">
      Se você quiser que o Smartnode gerencie um cliente de Consenso para você, a próxima tela pedirá que você escolha um cliente:

      <img src={tuiLocalCC} width="100%" height="auto"/>

      **A escolha preferida** para a saúde e diversidade geral da rede é a escolha **Aleatório (Recomendado)**, que escolherá aleatoriamente entre um dos quatro clientes de Consenso suportados para você.

      Se você preferir escolher um cliente explícito, consulte a seção [Escolhendo seus clientes ETH](./eth-clients#eth2-clients) para uma descrição de cada opção para que você possa tomar uma decisão informada.


      <p className="rspress-directive warning">
        <p className="rspress-directive-title">NOTA</p>
        Existem duas condições que irão apresentá-lo com avisos com base na seleção do cliente:

        - O cliente selecionado é atualmente [um cliente de supermaioria](https://clientdiversity.org/), o que significa que uma maioria não saudável de validadores na Beacon Chain o usa, o que ameaça a estabilidade da rede

        - O cliente selecionado é **muito pesado em recursos** para o hardware que você está usando atualmente

        Se algum desses casos for verdadeiro para o cliente escolhido, você será avisado e solicitado a escolher um cliente diferente.
        Você tem a opção de continuar a usar o que selecionou, mas deve estar ciente dos riscos ao fazer isso.
      </p>

      Depois de fazer sua escolha ou ter sido atribuído um cliente aleatório, clique na aba apropriada abaixo para aprender como configurá-lo:

      <div className="p-3">
        <Tabs>
          <Tab label="Lighthouse">
            A primeira opção na configuração do Lighthouse perguntará sobre a mensagem **graffiti** do seu validador:

            <img src={tuiLocalGraffiti} width="100%" height="auto"/>

            Esta é uma mensagem personalizada opcional que você pode anexar a quaisquer blocos que você propuser na Beacon Chain.
            A mensagem será preservada para sempre, então pense nisso como uma maneira divertida de deixar sua marca!

            **Observe que o comprimento máximo do graffiti é de 16 caracteres.**

            Se você gostaria de ver alguns exemplos do que os validadores estão usando para Graffiti hoje, [dê uma olhada aqui](https://beaconcha.in/blocks).

            Em seguida, há uma opção para habilitar ou desabilitar **Checkpoint Sync**:

            <img src={tuiLocalCheckpoint} width="100%" height="auto"/>

            O Lighthouse tem a capacidade de sincronizar instantaneamente para o bloco mais recente na rede Beacon Chain conectando-se a um Beacon Node existente em que você confia.
            Isso é preferível à sincronização convencional porque não requer nenhum tempo (enquanto a sincronização convencional pode levar dias) e vem com alguns benefícios de segurança.
            Dê uma olhada na [documentação deles sobre checkpoint syncing](https://lighthouse-book.sigmaprime.io/checkpoint-sync.html) para mais informações, se tiver curiosidade.

            Você pode inserir a URL de qualquer Beacon Node que forneça acesso à sua API REST aqui.

            Veja [a seção abaixo sobre Checkpoint Syncing](#sincronizacao-de-checkpoint-da-beacon-chain) se você gostaria de usá-lo.

            A pergunta final perguntará se você deseja habilitar a Proteção Doppelgänger:

            <img src={tuiLocalDD} width="100%" height="auto"/>

            O Lighthouse suporta um recurso chamado [Detecção Doppelgänger](https://lighthouse-book.sigmaprime.io/validator-doppelganger.html).
            Em poucas palavras, este recurso **intencionalmente** perderá alguns atestados após o reinício do Cliente Validador do Lighthouse; enquanto faz isso, ele ouvirá para ver se os atestados ainda estão sendo enviados para a rede usando suas chaves de validador.

            Idealmente, não haveria atestados (o que significa que nenhuma outra máquina está rodando com suas chaves de validador anexadas).
            Após seu curto período de espera, o Lighthouse começaria a validar normalmente.

            _No entanto_, se _houver_ outra máquina rodando com suas chaves de validador anexadas, o Lighthouse será imediatamente desligado e emitirá uma mensagem de erro em seus arquivos de log.
            A razão para isso é que, se ele começasse a atestar também, você começaria a **atestar em duplicidade**, o que é uma **ofensa passível de slashing**.
            Quando sofrer slashing, seu validador será forçosamente saído da Beacon Chain e você será penalizado com uma quantidade significativa de ETH.

            Na maioria das vezes, a detecção doppelgänger resultará em nada além de alguns atestados perdidos após a reinicialização do cliente.
            Em situações onde você está movendo seu validador para uma nova máquina ou está mudando para um novo cliente Beacon, no entanto, **a detecção doppelgänger pode evitar que você sofra slashing por atestar em duplicidade acidentalmente**.

            Pense nisso como um seguro barato para seus minipools; você perderá um pouco trivial de lucro toda vez que reiniciar, mas pode ter bastante certeza de que não executará acidentalmente suas chaves em dois lugares e sofrerá slashing por isso.

            A partir da versão 4.5.0, o Lighthouse tem uma opção para estabelecer conexões P2P de forma mais eficiente usando o [protocolo QUIC](https://en.wikipedia.org/wiki/QUIC). Se você estiver disposto a usar este recurso, precisará definir um campo extra de porta "Porta P2P QUIC" nas configurações ETH2 e encaminhá-la para seu node na configuração de encaminhamento de porta do seu roteador. A porta P2P QUIC padrão é 8001 (UDP). Certifique-se de evitar colisões com portas já em uso pelo seu node (ou nodes alternativos/testnet). Certifique-se também de que a mesma porta esteja aberta se você estiver usando um firewall em seu node (verifique `ufw status`).
            Para verificar se a configuração QUIC está funcionando, você deve ver um número de 2 dígitos após `libp2p_quic_peers` ao executar `docker run --network rocketpool_net curlimages/curl http://eth2:9100/metrics | grep libp2p_peers_multi`.

          </Tab>
          <Tab label="Nimbus">
            A primeira opção na configuração do Nimbus perguntará sobre a mensagem **graffiti** do seu validador:

            <img src={tuiLocalGraffiti} width="100%" height="auto"/>

            Esta é uma mensagem personalizada opcional que você pode anexar a quaisquer blocos que você propuser na Beacon Chain.
            A mensagem será preservada para sempre, então pense nisso como uma maneira divertida de deixar sua marca!

            **Observe que o comprimento máximo do graffiti é de 16 caracteres.**

            Se você gostaria de ver alguns exemplos do que os validadores estão usando para Graffiti hoje, [dê uma olhada aqui](https://beaconcha.in/blocks).

            Em seguida, há uma opção para habilitar ou desabilitar **Checkpoint Sync**:

            <img src={tuiLocalCheckpoint} width="100%" height="auto"/>

            O Nimbus tem a capacidade de sincronizar instantaneamente para o bloco mais recente na rede Beacon Chain conectando-se a um Beacon Node existente em que você confia.
            Isso é preferível à sincronização convencional porque não requer nenhum tempo (enquanto a sincronização convencional pode levar dias) e vem com alguns benefícios de segurança.
            Dê uma olhada na [documentação deles sobre checkpoint syncing](https://nimbus.guide/trusted-node-sync.html) para mais informações, se tiver curiosidade.

            Você pode inserir a URL de qualquer Beacon Node que forneça acesso à sua API REST aqui.

            Veja [a seção abaixo sobre Checkpoint Syncing](#sincronizacao-de-checkpoint-da-beacon-chain) se você gostaria de usá-lo.

            A pergunta final perguntará se você deseja habilitar a Proteção Doppelgänger:

            <img src={tuiLocalDD} width="100%" height="auto"/>

            O Nimbus suporta um recurso chamado [Proteção Doppelgänger](https://nimbus.guide/faq.html#why-does-my-validator-miss-two-epochs-of-attestations-after-restarting).
            Em poucas palavras, este recurso **intencionalmente** perderá alguns atestados após o reinício do Nimbus; enquanto faz isso, ele ouvirá para ver se os atestados ainda estão sendo enviados para a rede usando suas chaves de validador.

            Idealmente, não haveria atestados (o que significa que nenhuma outra máquina está rodando com suas chaves de validador anexadas).
            Após seu curto período de espera, o Nimbus começaria a validar normalmente.

            _No entanto_, se _houver_ outra máquina rodando com suas chaves de validador anexadas, o Nimbus será imediatamente desligado e emitirá uma mensagem de erro em seus arquivos de log.
            A razão para isso é que, se ele começasse a atestar também, você começaria a **atestar em duplicidade**, o que é uma **ofensa passível de slashing**.
            Quando sofrer slashing, seu validador será forçosamente saído da Beacon Chain e você será penalizado com uma quantidade significativa de ETH.

            Na maioria das vezes, a detecção doppelgänger resultará em nada além de alguns atestados perdidos após a reinicialização do cliente.
            Em situações onde você está movendo seu validador para uma nova máquina ou está mudando para um novo cliente Beacon, no entanto, **a detecção doppelgänger pode evitar que você sofra slashing por atestar em duplicidade acidentalmente**.

            Pense nisso como um seguro barato para seus minipools; você perderá um pouco trivial de lucro toda vez que reiniciar, mas pode ter bastante certeza de que não executará acidentalmente suas chaves em dois lugares e sofrerá slashing por isso.

          </Tab>
          <Tab label="Prysm">
            A primeira opção na configuração do Prysm perguntará sobre a mensagem **graffiti** do seu validador:

            <img src={tuiLocalGraffiti} width="100%" height="auto"/>

            This is an optional custom message you can attach to any blocks you propose on the Beacon Chain.
            The message will be preserved forever, so think of it like a fun little way to leave your mark!

            **Note the maximum length of the graffiti is 16 characters.**

            If you'd like to see some examples of what validators are using for Graffiti today, [take a look here](https://beaconcha.in/blocks).

            Next up is an option to enable or disable **Checkpoint Sync**:

            <img src={tuiLocalCheckpoint} width="100%" height="auto"/>

            Prysm has the ability to instantly sync to the latest block on the Beacon Chain network by connecting to an existing Beacon Node that you trust.
            This is preferred over conventional syncing because it doesn't require any time (whereas conventional syncing can take days) and comes with some security benefits.
            Take a look at [their documentation on checkpoint syncing](https://docs.prylabs.network/docs/prysm-usage/checkpoint-sync) for more information if you are curious.

            You can enter the URL of any Beacon Node that provides access to its REST API here.

            See [the section below on Checkpoint Syncing](#beacon-chain-checkpoint-syncing) if you'd like to use it.

            The final question will ask if you want to enable Doppelgänger Protection:

            <img src={tuiLocalDD} width="100%" height="auto"/>

            O Prysm suporta um recurso chamado Proteção Doppelgänger.
            Em poucas palavras, este recurso **intencionalmente** perderá alguns atestados após o reinício do Cliente Validador do Prysm; enquanto faz isso, ele ouvirá para ver se os atestados ainda estão sendo enviados para a rede usando suas chaves de validador.

            Idealmente, não haveria atestados (o que significa que nenhuma outra máquina está rodando com suas chaves de validador anexadas).
            Após seu curto período de espera, o Prysm começaria a validar normalmente.

            _No entanto_, se _houver_ outra máquina rodando com suas chaves de validador anexadas, o Prysm será imediatamente desligado e emitirá uma mensagem de erro em seus arquivos de log.
            A razão para isso é que, se ele começasse a atestar também, você começaria a **atestar em duplicidade**, o que é uma **ofensa passível de slashing**.
            Quando sofrer slashing, seu validador será forçosamente saído da Beacon Chain e você será penalizado com uma quantidade significativa de ETH.

            Na maioria das vezes, a detecção doppelgänger resultará em nada além de alguns atestados perdidos após a reinicialização do cliente.
            Em situações onde você está movendo seu validador para uma nova máquina ou está mudando para um novo cliente Beacon, no entanto, **a detecção doppelgänger pode evitar que você sofra slashing por atestar em duplicidade acidentalmente**.

            Pense nisso como um seguro barato para seus minipools; você perderá um pouco trivial de lucro toda vez que reiniciar, mas pode ter bastante certeza de que não executará acidentalmente suas chaves em dois lugares e sofrerá slashing por isso.

          </Tab>
          <Tab label="Teku">
            A primeira opção na configuração do Teku perguntará sobre a mensagem **graffiti** do seu validador:

            <img src={tuiLocalGraffiti} width="100%" height="auto"/>

            Esta é uma mensagem personalizada opcional que você pode anexar a quaisquer blocos que você propuser na Beacon Chain.
            A mensagem será preservada para sempre, então pense nisso como uma maneira divertida de deixar sua marca!

            **Observe que o comprimento máximo do graffiti é de 16 caracteres.**

            Se você gostaria de ver alguns exemplos do que os validadores estão usando para Graffiti hoje, [dê uma olhada aqui](https://beaconcha.in/blocks).

            A pergunta final é uma opção para habilitar ou desabilitar **Checkpoint Sync**:

            <img src={tuiLocalCheckpoint} width="100%" height="auto"/>

            O Teku tem a capacidade de sincronizar instantaneamente para o bloco mais recente na rede Beacon Chain conectando-se a um Beacon Node existente em que você confia.
            Isso é preferível à sincronização convencional porque não requer nenhum tempo (enquanto a sincronização convencional pode levar dias) e vem com alguns benefícios de segurança.
            Dê uma olhada na [documentação deles sobre checkpoint syncing](https://docs.teku.consensys.net/en/latest/HowTo/Get-Started/Checkpoint-Start/) para mais informações, se tiver curiosidade.

            Você pode inserir a URL de qualquer Beacon Node que forneça acesso à sua API REST aqui.

            Veja [a seção abaixo sobre Checkpoint Syncing](#sincronizacao-de-checkpoint-da-beacon-chain) se você gostaria de usá-lo.
          </Tab>
          <Tab label="Lodestar">
            A primeira opção na configuração do Lodestar perguntará sobre a mensagem **graffiti** do seu validador:

            <img src={tuiLocalGraffiti} width="100%" height="auto"/>

            Esta é uma mensagem personalizada opcional que você pode anexar a quaisquer blocos que você propuser na Beacon Chain.
            A mensagem será preservada para sempre, então pense nisso como uma maneira divertida de deixar sua marca!

            **Observe que o comprimento máximo do graffiti é de 16 caracteres.**

            Se você gostaria de ver alguns exemplos do que os validadores estão usando para Graffiti hoje, [dê uma olhada aqui](https://beaconcha.in/blocks).

            Em seguida, há uma opção para habilitar ou desabilitar **Checkpoint Sync**:

            <img src={tuiLocalCheckpoint} width="100%" height="auto"/>

            O Lodestar tem a capacidade de sincronizar instantaneamente para o bloco mais recente na rede Beacon Chain conectando-se a um Beacon Node existente em que você confia.
            Isso é preferível à sincronização convencional porque não requer nenhum tempo (enquanto a sincronização convencional pode levar dias) e vem com alguns benefícios de segurança.
            Dê uma olhada na [documentação deles sobre checkpoint syncing](https://chainsafe.github.io/lodestar/run/beacon-management/starting-a-node#checkpoint-sync) para mais informações, se tiver curiosidade.

            Você pode inserir a URL de qualquer Beacon Node que forneça acesso à sua API REST aqui.

            Veja [a seção abaixo sobre Checkpoint Syncing](#sincronizacao-de-checkpoint-da-beacon-chain) se você gostaria de usá-lo.

            A pergunta final perguntará se você deseja habilitar a Proteção Doppelgänger:

            <img src={tuiLocalDD} width="100%" height="auto"/>

            O Lodestar suporta um recurso chamado Detecção Doppelgänger.
            Em poucas palavras, este recurso **intencionalmente** perderá alguns atestados após o reinício do Cliente Validador do Lodestar; enquanto faz isso, ele ouvirá para ver se os atestados ainda estão sendo enviados para a rede usando suas chaves de validador.

            Idealmente, não haveria atestados (o que significa que nenhuma outra máquina está rodando com suas chaves de validador anexadas).
            Após seu curto período de espera, o Lodestar começaria a validar normalmente.

            _No entanto_, se _houver_ outra máquina rodando com suas chaves de validador anexadas, o Lodestar será imediatamente desligado e emitirá uma mensagem de erro em seus arquivos de log.
            A razão para isso é que, se ele começasse a atestar também, você começaria a **atestar em duplicidade**, o que é uma **ofensa passível de slashing**.
            Quando sofrer slashing, seu validador será forçosamente saído da Beacon Chain e você será penalizado com uma quantidade significativa de ETH.

            Na maioria das vezes, a detecção doppelgänger resultará em nada além de alguns atestados perdidos após a reinicialização do cliente.
            Em situações onde você está movendo seu validador para uma nova máquina ou está mudando para um novo cliente Beacon, no entanto, **a detecção doppelgänger pode evitar que você sofra slashing por atestar em duplicidade acidentalmente**.

            Pense nisso como um seguro barato para seus minipools; você perderá um pouco trivial de lucro toda vez que reiniciar, mas pode ter bastante certeza de que não executará acidentalmente suas chaves em dois lugares e sofrerá slashing por isso.

          </Tab>
        </Tabs>
      </div>

      <p className="rspress-directive warning">
        <p className="rspress-directive-title">NOTA</p>
        **Abra a porta P2P na configuração de encaminhamento de porta do seu roteador**. Configure-o para encaminhar a **porta 9001** em TCP e UDP para o endereço IP local da sua máquina.
        Dessa forma, outros clientes de Consenso podem descobri-lo e se comunicar com ele de fora. Isso ajudará seu cliente de Consenso a sincronizar rapidamente e melhorar o desempenho (e, portanto, as recompensas).

        Cada roteador tem uma maneira diferente de fazer isso, então **você precisará verificar o manual do seu roteador sobre como configurar o encaminhamento de porta**
      </p>
    </Tab>
    <Tab label="Gerenciado Externamente">
      Como cada cliente de Consenso tem comportamento ligeiramente diferente, o Smartnode precisa saber qual você está usando externamente para que possa adaptar seu próprio comportamento de acordo.
      Comece escolhendo qual cliente você tem na lista na próxima tela:

      <img src="./images/tui-external-cc.png" width="100%" height="auto"/>


      <p className="rspress-directive warning">
        <p className="rspress-directive-title">NOTA</p>
        Neste momento, **Nimbus** não é compatível com o modo Externo porque ainda não pode ser executado como um Validator Container (VC) autônomo.
        Quando o cliente suportar este recurso, ele será adicionado à lista aqui.
      </p>

      Selecione seu cliente nas abas abaixo para aprender como concluir a configuração.

      <div className="p-3">
        <Tabs>
          <Tab label="Lighthouse">
            Comece especificando a URL para a API do seu Beacon Node do Lighthouse:

            <img src={tuiExternalLH} width="100%" height="auto"/>

            O Smartnode usará a URL HTTP para se comunicar com ele e executar atividades de blockchain, como consultar o estado da cadeia e enviar mensagens.
            **Se você ainda não tiver a porta da API habilitada e acessível a partir da sua máquina Smartnode, você precisará configurá-la agora.**
            Veja a [documentação do Lighthouse](https://lighthouse-book.sigmaprime.io/api-bn.html) para instruções sobre como fazer isso.

            <p className="rspress-directive warning">
              <p className="rspress-directive-title">NOTA</p>
              Como o Smartnode será executado em seu próprio contêiner Docker, ele usará a rede interna do Docker.
              Você não poderá usar nomes de host como `localhost` ou `127.0.0.1` aqui; se o seu cliente estiver rodando na mesma máquina que o Smartnode, você precisará fornecer o endereço IP LAN da máquina.
            </p>


            Em seguida, perguntará sobre a mensagem **graffiti** do seu validador:

            <img src={tuiExternalGraffiti} width="100%" height="auto"/>

            Esta é uma mensagem personalizada opcional que você pode anexar a quaisquer blocos que você propuser na Beacon Chain.
            A mensagem será preservada para sempre, então pense nisso como uma maneira divertida de deixar sua marca!

            **Observe que o comprimento máximo do graffiti é de 16 caracteres.**

            Se você gostaria de ver alguns exemplos do que os validadores estão usando para Graffiti hoje, [dê uma olhada aqui](https://beaconcha.in/blocks).

            A pergunta final perguntará se você deseja habilitar a Proteção Doppelgänger:

            <img src={tuiExternalDD} width="100%" height="auto"/>

            O Lighthouse suporta um recurso chamado [Detecção Doppelgänger](https://lighthouse-book.sigmaprime.io/validator-doppelganger.html).
            Em poucas palavras, este recurso **intencionalmente** perderá alguns atestados após o reinício do Cliente Validador do Lighthouse; enquanto faz isso, ele ouvirá para ver se os atestados ainda estão sendo enviados para a rede usando suas chaves de validador.

            Idealmente, não haveria atestados (o que significa que nenhuma outra máquina está rodando com suas chaves de validador anexadas).
            Após seu curto período de espera, o Lighthouse começaria a validar normalmente.

            _No entanto_, se _houver_ outra máquina rodando com suas chaves de validador anexadas, o Lighthouse será imediatamente desligado e emitirá uma mensagem de erro em seus arquivos de log.
            A razão para isso é que, se ele começasse a atestar também, você começaria a **atestar em duplicidade**, o que é uma **ofensa passível de slashing**.
            Quando sofrer slashing, seu validador será forçosamente saído da Beacon Chain e você será penalizado com uma quantidade significativa de ETH.

            Na maioria das vezes, a detecção doppelgänger resultará em nada além de alguns atestados perdidos após a reinicialização do cliente.
            Em situações onde você está movendo seu validador para uma nova máquina ou está mudando para um novo cliente Beacon, no entanto, **a detecção doppelgänger pode evitar que você sofra slashing por atestar em duplicidade acidentalmente**.

            Pense nisso como um seguro barato para seus minipools; você perderá um pouco trivial de lucro toda vez que reiniciar, mas pode ter bastante certeza de que não executará acidentalmente suas chaves em dois lugares e sofrerá slashing por isso.

          </Tab>
          <Tab label="Prysm">
            Comece especificando a URL para a API do seu Beacon Node do Prysm e a URL para sua API JSON-RPC:

            <img src={tuiExternalPrysm} width="100%" height="auto"/>

            O Smartnode usará a URL HTTP para se comunicar com ele e executar atividades de blockchain, como consultar o estado da cadeia e enviar mensagens.
            Ele preparará seu Cliente Validador Prysm com a URL JSON-RPC para que possa se comunicar com seu Beacon Node, pois _o Cliente Validador do Prysm atualmente não pode funcionar pela API HTTP._

            **Se você ainda não tiver as portas da API habilitadas e acessíveis a partir da sua máquina Smartnode, você precisará configurá-las agora.**
            Veja a [documentação do Prysm](https://docs.prylabs.network/docs/prysm-usage/parameters) para instruções sobre como fazer isso.
            **Você precisará do `grpc-gateway` _e_ do `rpc-host` habilitados.**

            <p className="rspress-directive warning">
              <p className="rspress-directive-title">NOTA</p>
              Como o Smartnode será executado em seu próprio contêiner Docker, ele usará a rede interna do Docker.
              Você não poderá usar nomes de host como `localhost` ou `127.0.0.1` aqui; se o seu cliente estiver rodando na mesma máquina que o Smartnode, você precisará fornecer o endereço IP LAN da máquina.
            </p>


            Em seguida, perguntará sobre a mensagem **graffiti** do seu validador:

            <img src={tuiExternalGraffiti} width="100%" height="auto"/>

            Esta é uma mensagem personalizada opcional que você pode anexar a quaisquer blocos que você propuser na Beacon Chain.
            A mensagem será preservada para sempre, então pense nisso como uma maneira divertida de deixar sua marca!

            **Observe que o comprimento máximo do graffiti é de 16 caracteres.**

            Se você gostaria de ver alguns exemplos do que os validadores estão usando para Graffiti hoje, [dê uma olhada aqui](https://beaconcha.in/blocks).

            A pergunta final perguntará se você deseja habilitar a Proteção Doppelgänger:

            <img src={tuiExternalDD} width="100%" height="auto"/>

            O Prysm suporta um recurso chamado Proteção Doppelgänger.
            Em poucas palavras, este recurso **intencionalmente** perderá alguns atestados após o reinício do Cliente Validador do Prysm; enquanto faz isso, ele ouvirá para ver se os atestados ainda estão sendo enviados para a rede usando suas chaves de validador.

            Idealmente, não haveria atestados (o que significa que nenhuma outra máquina está rodando com suas chaves de validador anexadas).
            Após seu curto período de espera, o Prysm começaria a validar normalmente.

            _No entanto_, se _houver_ outra máquina rodando com suas chaves de validador anexadas, o Prysm será imediatamente desligado e emitirá uma mensagem de erro em seus arquivos de log.
            A razão para isso é que, se ele começasse a atestar também, você começaria a **atestar em duplicidade**, o que é uma **ofensa passível de slashing**.
            Quando sofrer slashing, seu validador será forçosamente saído da Beacon Chain e você será penalizado com uma quantidade significativa de ETH.

            Na maioria das vezes, a detecção doppelgänger resultará em nada além de alguns atestados perdidos após a reinicialização do cliente.
            Em situações onde você está movendo seu validador para uma nova máquina ou está mudando para um novo cliente Beacon, no entanto, **a detecção doppelgänger pode evitar que você sofra slashing por atestar em duplicidade acidentalmente**.

            Pense nisso como um seguro barato para seus minipools; você perderá um pouco trivial de lucro toda vez que reiniciar, mas pode ter bastante certeza de que não executará acidentalmente suas chaves em dois lugares e sofrerá slashing por isso.

          </Tab>
          <Tab label="Teku">
            Comece especificando a URL para a API do seu Beacon Node do Teku:

            <img src={tuiExternalTeku} width="100%" height="auto"/>

            O Smartnode usará a URL HTTP para se comunicar com ele e executar atividades de blockchain, como consultar o estado da cadeia e enviar mensagens.
            **Se você ainda não tiver a porta da API habilitada e acessível a partir da sua máquina Smartnode, você precisará configurá-la agora.**
            Veja a [documentação do Teku](https://docs.teku.consensys.net/en/latest/Reference/CLI/CLI-Syntax/#rest-api-enabled) para instruções sobre como fazer isso.


            <p className="rspress-directive warning">
              <p className="rspress-directive-title">NOTA</p>
              Como o Smartnode será executado em seu próprio contêiner Docker, ele usará a rede interna do Docker.
              Você não poderá usar nomes de host como `localhost` ou `127.0.0.1` aqui; se o seu cliente estiver rodando na mesma máquina que o Smartnode, você precisará fornecer o endereço IP LAN da máquina.
            </p>

            Em seguida, perguntará sobre a mensagem **graffiti** do seu validador:

            <img src={tuiExternalGraffiti} width="100%" height="auto"/>

            Esta é uma mensagem personalizada opcional que você pode anexar a quaisquer blocos que você propuser na Beacon Chain.
            A mensagem será preservada para sempre, então pense nisso como uma maneira divertida de deixar sua marca!

            **Observe que o comprimento máximo do graffiti é de 16 caracteres.**

            Se você gostaria de ver alguns exemplos do que os validadores estão usando para Graffiti hoje, [dê uma olhada aqui](https://beaconcha.in/blocks).
          </Tab>

        </Tabs>
      </div>
    </Tab>

  </Tabs>
</div>

#### Sincronização de Checkpoint da Beacon Chain

**Checkpoint syncing** é uma técnica muito útil que alguns clientes Beacon Chain suportam.
Ele permite que seu cliente Beacon sincronize instantaneamente toda a Beacon Chain sem ter que começar do início e acompanhar cada bloco.
Isso significa que, em vez de levar **dias**, seu cliente Beacon pode estar pronto em questão de **minutos**.
Tudo o que ele precisa é acesso a um cliente Beacon existente em que você confia.

Você pode usar qualquer Beacon node que forneça acesso à sua API HTTP.
Atualmente, muitos operadores de node estão usando os checkpoint-sync-endpoints - um serviço que permite aos operadores de node Rocket Pool fazer checkpoint sync facilmente.
Tanto a Hoodi Testnet quanto a Mainnet são suportadas.
Uma lista de URLs de checkpoint sync pode ser encontrada através do seguinte link:

- [URLs de Checkpoint Sync](https://eth-clients.github.io/checkpoint-sync-endpoints/)

Escolha uma URL de checkpoint sync relevante e cole no terminal durante `rocketpool service config` quando ele solicitar um Provedor de Checkpoint Sync.

Depois disso, seu Beacon node se conectará automaticamente ao node de checkpoint sync quando iniciar pela primeira vez e instantaneamente baixará o estado mais recente da cadeia!

::: warning NOTA
O Checkpoint Sync só ocorrerá se você _ainda não tiver nenhum dado da Beacon Chain_.
Em outras palavras, se você começar a sincronizar normalmente e decidir fazer checkpoint sync mais tarde, terá que remover seus dados da cadeia primeiro para que o checkpoint sync funcione.
Isso pode ser feito facilmente com o seguinte comando:

```shell
rocketpool service resync-eth2
```

:::

### Node Alternativo

A partir da versão 1.5.0 da stack do Smartnode, você pode fornecer um par de cliente de Execução e cliente de Consenso "alternativo" que pode assumir seus clientes primários se eles ficarem offline (como quando você usa Geth e precisa podá-lo).
Nesta situação, sua máquina de node primária ainda será responsável por atestar e propor blocos com as chaves de validador de seus minipools, mas se conectará a uma máquina externa para interagir com as cadeias de camada de Execução e Beacon.

[Para saber mais sobre nodes alternativos, veja esta seção](./fallback) e retorne aqui quando terminar.

### Configuração de Métricas

Rocket Pool vem com a capacidade de exibir um painel detalhado mostrando métricas sobre a saúde do hardware do seu node, atualizações do sistema, desempenho do seu validador, suas recompensas, informações sobre a rede geral do Rocket Pool e muito mais:

<img src="./images/nimbus-dashboard.png" width="100%" height="auto" />

A próxima pergunta no Assistente perguntará se você deseja habilitar isso:

<img src="./images/tui-metrics.png" width="100%" height="auto" />

Se você optar por habilitá-lo, aprenderá mais sobre como configurá-lo e como usá-lo na seção [Configurando o Painel Grafana](./grafana) mais adiante no processo.

::: warning NOTA
Todos os dados coletados por este sistema **permanecem em sua máquina**.
Rocket Pool não coleta nenhuma telemetria nem a envia para um serviço separado.
Está lá puramente para você usar para que possa monitorar seu próprio node!
:::

### Configuração MEV

Desde a Fusão das camadas de Execução e Consenso em setembro de 2022, os validadores Ethereum agora têm a capacidade de ganhar taxas de prioridade e participar do Valor Máximo Extraível (ou MEV, na sigla em inglês).

A partir do Smartnode v1.7.0, MEV agora é _opt-out_, então sua configuração é apresentada como parte da configuração inicial, como você vê na próxima tela:

<img src="./images/tui-mev-mode.png" width="100%" height="auto" />

[Por favor, leia nosso guia MEV para aprender mais sobre MEV, sua configuração e o que fazer nesta seção do assistente.](./mev)
Retorne aqui quando terminar.

### Conclusão

Após esta pergunta, você terminou de configurar o Smartnode!
Você verá o seguinte diálogo:

<img src="./images/tui-finished.png" width="100%" height="auto" />

Se você está satisfeito com sua configuração e está pronto para iniciar o Smartnode, clique em `Save and Exit` aqui e vá para a seção [Protegendo seu Node](./securing-your-node) em seguida.

Se você gostaria de revisar todas as configurações e personalizar muitas configurações adicionais que não foram incluídas no Assistente, clique em `Review All Settings` e vá para a [próxima seção](#configurando-via-gerenciador-de-configuracoes).

## Configurando via Gerenciador de Configurações

Se você já executou `rocketpool service config`, em vez de ser recebido pelo Assistente, você verá a tela do **Gerenciador de Configurações**:

<img src="./images/tui-settings-manager.png" width="100%" height="auto" />

Existem três recursos principais desta tela:

1. A **Lista de Categorias**, que permite detalhar as configurações de cada categoria da stack do Smartnode
2. O botão **Review Changes and Save**, que você pode usar quando estiver pronto para ver quais configurações você alterou e salvar a configuração atualizada
3. O botão **Open the Config Wizard**, que levará você ao [Assistente de Configuração](#configurando-a-stack-do-smartnode-via-assistente) se você preferir essa interface

::: tip DICA
Para usar o Gerenciador de Configurações, **pressione as `Setas` (cima/baixo/esquerda/direita) para navegar entre as opções na página inicial**.

Pressione `Tab` para alternar **entre a lista de categorias (1) e os botões (2 e 3)** na parte inferior da tela.
O botão atualmente selecionado será **destacado em verde**.

**Pressione `Enter` ou `Espaço` para selecionar um botão**, análogo a clicar nele com o mouse.

**Mantenha `Ctrl` pressionado e pressione `C` a qualquer momento para sair do Gerenciador de Configurações sem salvar nada**.
:::

À medida que você percorre a lista de categorias, cada opção terá uma descrição útil na **Caixa de Descrição** à direita da tela.
Sinta-se à vontade para explorá-las; nada do que você fizer será salvo até que você passe pelo diálogo de Revisão através do botão **Review Changes and Save**, e você pode pressionar **Ctrl+C** a qualquer momento para sair sem salvar, então você não bagunçará acidentalmente algo ao brincar com as configurações aqui.

### Configurando as Configurações

Na tela inicial, selecione qualquer uma das categorias com a tecla `Enter` para visualizar as configurações dessa categoria.
Por exemplo, aqui está a tela para a categoria **Smartnode e Taxas TX**:

<img src="./images/tui-smartnode.png" width="100%" height="auto" />

Use as `Setas` para se mover para cima e para baixo entre as configurações.
A atualmente selecionada terá um quadrado branco no final (se for uma caixa de texto ou uma caixa de seleção), ou será destacada em branco (se for uma lista suspensa).

Pressione `Escape` para voltar à tela inicial do Gerenciador de Configurações quando terminar.

À medida que você percorre as configurações, cada uma mostrará uma breve descrição do que faz na **Caixa de Descrição** à direita.
Também mostrará o **valor padrão** lá, caso você queira revertê-lo para sua configuração original.

Neste exemplo, a configuração **RPL Claim Gas Threshold** está atualmente selecionada (destacada com uma caixa verde no lado esquerdo da tela).
Foi alterada para `40`, mas você pode ver que tem um padrão de `150` no canto superior direito (o topo da **Caixa de Descrição**).

::: tip DICA
Como lembrete, nada será salvo no disco até que você passe pelo diálogo de Revisão através do botão **Review Changes and Save**.
Você é encorajado a explorar todas as configurações para aprender sobre elas e ver o que seu Smartnode pode fazer!
:::

### Os Tipos de Configuração e Como Usá-los

O gerenciador de configurações usa os seguintes tipos de configuração e elementos de interface:

#### Caixas de Texto

Caixas de texto são usadas para inserir strings de texto ou números arbitrários.
Elas se parecem com isto:

<img src="./images/tui-textbox.png" width="100%" height="auto" />

Insira os valores desejados nelas, depois **pressione `Enter` ou use as `Setas` para navegar para uma configuração diferente a fim de preservar suas alterações.**
Se você não fizer isso, o Gerenciador de Configurações assumirá que você ainda está atualizando essa configuração e não a marcará como alterada ainda.

#### Listas Suspensas

Listas suspensas são usadas para selecionar uma opção de uma lista de escolhas.
Elas se parecem com isto (quando estão abertas):

<img src="./images/tui-dropdown-open.png" width="100%" height="auto" />

O item **verde** é o que está atualmente selecionado.
Use as `Setas` para alterar opções - ao fazer isso, a **Caixa de Descrição** à direita será atualizada para lhe contar mais sobre a opção atualmente selecionada.
Quando estiver satisfeito com sua escolha, pressione `Enter` para escolher a opção selecionada e a lista suspensa será fechada, revelando a opção que está atualmente selecionada:

<img src="./images/tui-dropdown-closed.png" width="100%" height="auto" />

#### Caixas de Seleção

Caixas de seleção são usadas para perguntas simples de Sim/Não.
Elas se parecem com isto:

<img src="./images/tui-checkbox-checked.png" width="100%" height="auto" />

Quando estão marcadas, terão um `X` no meio como você vê acima.
Quando estão _desmarcadas_, estarão simplesmente em branco assim:

<img src="./images/tui-checkbox-unchecked.png" width="100%" height="auto" />

Para alterar a configuração, basta selecioná-la e pressionar `Enter`.

### Salvando Alterações

Quando estiver satisfeito com suas alterações e quiser revisá-las antes de salvar, pressione o botão **Review Changes and Save** na tela inicial.
Como lembrete, para chegar até ele, pressione a tecla `Tab`.

Você será apresentado com uma visualização que se parece com isto:

<img src="./images/tui-review.png" width="100%" height="auto" />

A **Caixa de Revisão** aqui apresentará todas as configurações que você alterou, mostrando os valores antigos e os novos.
Por exemplo, a primeira linha aqui mostra que o **RPL Claim Gas Threshold** costumava ser `150`, e foi alterado para `40`.

Também mostrará quais contêineres são afetados pelas configurações que você modificou e se oferecerá para reiniciá-los para você após você salvar suas alterações.

::: tip NOTA
Neste ponto, suas alterações **ainda não foram salvas**.
Se você quiser voltar e modificar algo, pressione `Escape` para retornar à tela inicial.
:::

Quando estiver satisfeito com as alterações, pressione `Enter` para salvar a nova configuração no disco.
Você então sairá da Interface de Terminal e será apresentado com algo como esta mensagem:

```
Your changes have been saved!
The following containers must be restarted for the changes to take effect:
	rocketpool_watchtower
	rocketpool_validator
	rocketpool_eth2
	rocketpool_node
Would you like to restart them automatically now? [y/n]
```

Pressione `y` e `Enter` se quiser aplicar automaticamente suas novas alterações de configuração e reiniciar os contêineres afetados.

Pressione `n` e `Enter` se tiver outras coisas que deseja fazer antes de reiniciá-los e fará isso manualmente mais tarde.

Em ambos os casos, sua configuração está pronta!

::: tip NOTA
Você pode ver uma mensagem de erro como a abaixo:

```
2022/08/13 13:49:41 Error piping stdout: read |0: file already closed
```

Isso não é realmente um erro, é simplesmente uma falha cosmética.
Você pode ignorá-lo com segurança.
:::

::: tip NOTA
Se você estiver executando Mac OS, poderá ver um problema reclamando sobre node_exporter.
Você precisará executar esses comandos para corrigir.

```shell
rocketpool service stop
nano ~/.rocketpool/override/exporter.yml
```

Substitua todo o conteúdo do arquivo por:

```
# Enter your own customizations for the node exporter container here. These changes will persist after upgrades, so you only need to do them once.
#
# See https://docs.docker.com/compose/extends/#adding-and-overriding-configuration
# for more information on overriding specific parameters of docker-compose files.

version: "3.7"
services:
  node-exporter:
    x-rp-comment: Add your customizations below this line
    volumes:   ["/proc:/host/proc:ro","/sys:/host/sys:ro"]
```

então, finalmente, `rocketpool service start`.
:::

## Configurando via Linha de Comando

Se você usar o Smartnode em um ambiente sem interface onde não pode interagir com a Interface de Terminal, pode configurar seu node através da linha de comando.

O comando `rocketpool service config` aceita, como argumentos, todas as configurações que normalmente podem ser configuradas através da Interface de Terminal.
Execute o seguinte comando para ver uma lista delas (observe que é bastante longa):

```shell
rocketpool service config --help
```

A saída será parecida com isto:

```
NAME:
   rocketpool service config - Configure the Rocket Pool service

USAGE:
   rocketpool service config

OPTIONS:
   --executionClientMode value  Choose which mode to use for your Execution client - locally managed (Docker Mode), or externally managed (Hybrid Mode).
                                Type: choice
                                Options: local, external
 (default: "local")
   --executionClient value  Select which Execution client you would like to run.
                            Type: choice
                            Options: geth, infura, pocket
 (default: "geth")
   --useFallbackExecutionClient         Enable this if you would like to specify a fallback Execution client, which will temporarily be used by the Smartnode and your Consensus client if your primary Execution client ever goes offline.
                                        Type: bool

...
```

Cada opção terá seu nome, seu tipo, seu valor padrão e (se for um parâmetro de escolha) suas opções.
Usando este texto, você pode encontrar a(s) opção(ões) que deseja definir e especificá-las através dos argumentos apropriados.

::: tip NOTA
Este comando se baseia em sua configuração existente, então se você já tem algumas configurações salvas e quer apenas modificar outras, não precisa repeti-las.
Ele atualizará apenas as configurações que você incluir como argumentos para este comando.
:::

## Próximos Passos

Depois de configurar seu node da maneira que você deseja, você está pronto para proteger seu sistema operacional para proteger seu node.
Vá para a seção [Protegendo seu Node](./securing-your-node) em seguida.
