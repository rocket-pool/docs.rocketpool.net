---
next:
  text: "Tailscale"
  link: "/pt/node-staking/tailscale"
---

import { Tab, Tabs } from "@rspress/core/theme";

# Protegendo seu Node

O objetivo deste guia é orientá-lo através das etapas que você pode tomar para proteger seu node contra agentes maliciosos.
Seja você executando um servidor local em casa ou um servidor VPS / máquina virtual na nuvem, as dicas aqui ajudarão você a fortalecer seu node contra ataques externos e ajudá-lo a protegê-lo durante sua vida útil.

Esta seção descreverá ações **essenciais**, que você **deve** tomar, e ações **boas de ter**, que são úteis, mas não obrigatórias.

::: tip NOTA
Este guia é uma **introdução** a algumas das coisas que você pode fazer para fortalecer a máquina do seu node.
Se você se sentir confortável com o terminal de linha de comando e quiser ir ainda mais longe na proteção do seu node, dê uma olhada no popular guia [imthenachoman/How-To-Secure-A-Linux-Server](https://github.com/imthenachoman/How-To-Secure-A-Linux-Server).
:::

## Premissas neste Guia

Este guia assume que seu node executa `Ubuntu 20.04 LTS`.
Os conceitos serão transferidos para outros sistemas, mas os comandos de exemplo podem não funcionar.

Como em todos os comandos neste guia, assumimos que você está se conectando **remotamente** ao terminal de comando do seu node usando `ssh`.
Se você precisar de uma recapitulação sobre como usar `ssh`, dê uma olhada primeiro no guia [Introdução ao Secure Shell](./ssh).

## ESSENCIAL: Mantenha sua Máquina Cliente Segura

::: warning NOTA
Se você usa seu Smartnode localmente (fazendo login fisicamente com um teclado e monitor diretamente conectados a ele), então **esta seção não é relevante para você - você pode pular**.
:::

A maioria dos operadores de Smartnode interage com seu node remotamente conectando-se ao seu terminal de outro computador usando `ssh`:

- A máquina à qual você se conecta (neste caso, a máquina do seu node) é chamada de **servidor**.
- A máquina da qual você se conecta (como seu laptop, desktop ou até mesmo seu telefone) é o **cliente**.

Uma das coisas mais importantes que você pode fazer para proteger seu Smartnode é **manter sua máquina cliente segura**.
Se sua máquina cliente estiver comprometida e você a usar para fazer login no seu node, então a maioria das configurações de segurança que você aplicar ao node poderá ser ignorada.

Por exemplo: se você usar um laptop como cliente SSH e ele tiver um [keylogger](https://en.wikipedia.org/wiki/Keystroke_logging) instalado, então quaisquer coisas secretas que você digitar no node (como sua senha ou mnemônico de recuperação) quando conectado via SSH serão roubadas.

Não há um guia definitivo para manter sua máquina cliente segura, mas estar ciente de que é um fator em sua segurança é um bom primeiro passo.
Certifique-se de que sua máquina cliente esteja tão segura quanto possível.

Aqui estão algumas dicas:

- Não use sua máquina cliente para **atividades arriscadas** (como visitar sites não confiáveis ou instalar programas desnecessários)
- Mantenha sua máquina cliente atualizada com os **patches de segurança mais recentes**
- Se possível, use um programa de **proteção contra malware e antivírus** para seu Sistema Operacional

Para máxima segurança, você pode querer usar uma **máquina dedicada** como seu cliente SSH, embora isso possa não ser prático para você.

## ESSENCIAL: Proteja seu Acesso SSH

::: warning NOTA
Se você usa seu Smartnode localmente (fazendo login fisicamente com um teclado e monitor diretamente conectados a ele), então **esta seção não é relevante para você - você pode pular**.
:::

Seja você executando seu Smartnode em casa ou usando um VPS em um datacenter remoto, é provável que você acesse através de SSH, ou que o SSH esteja habilitado **mesmo que você não o use**.

As conexões SSH são baseadas em criptografia segura, mas como em qualquer sistema seguro, a segurança real vem de usá-lo corretamente.
Há duas coisas principais a fazer para suas configurações SSH:

1. Use uma chave SSH para fazer login remotamente em vez de um nome de usuário e senha
2. Desabilite completamente a autenticação baseada em senha, para que as chaves SSH sejam a única opção de login remoto

Como você provavelmente está familiarizado agora, a maneira padrão de fazer login no seu node via SSH é com um nome de usuário e senha.
A desvantagem disso é que sua senha é tipicamente algo bastante "curto" e suscetível a [ataques de força bruta](https://en.wikipedia.org/wiki/Brute-force_attack).

Felizmente, há uma maneira alternativa de fazer login via SSH: um **par de chaves SSH**.

Os pares de chaves SSH funcionam de forma semelhante às carteiras blockchain; eles vêm com uma parte pública (como seu endereço de carteira) e uma parte privada (a chave privada para seu endereço de carteira):

- Você fornece a **parte pública** ao seu node. Dessa forma, o node sabe que você tem permissão para se conectar a ele e sabe que é realmente você tentando se conectar.
- Você mantém a **parte privada** consigo na sua máquina cliente. Dessa forma, você (e somente você) pode se conectar ao seu node.
  - Você pode (e deve!) proteger a parte privada com uma **senha**, para que alguém que roube sua chave não possa usá-la.
- Do ponto de vista de um computador, a chave privada é **exponencialmente mais difícil** de quebrar do que uma senha. Isso mitiga o risco de um ataque de força bruta contra seu node.

::: tip DICA
Se você gostaria de aprender mais sobre pares de chaves SSH antes de criar o seu próprio, dê uma olhada nestes links:

- [https://canvas.cse.taylor.edu/courses/27/pages/ssh-key-tutorial](https://canvas.cse.taylor.edu/courses/27/pages/ssh-key-tutorial)
- [https://www.ssh.com/academy/ssh/host-key](https://www.ssh.com/academy/ssh/host-key)

:::

### Criando um Par de Chaves SSH

Vamos começar criando um novo par de chaves SSH **na sua máquina cliente**.
Existem muitas variedades de chaves por aí, mas vamos usar um tipo de chave chamado [ed25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519) que fornece excelente segurança.

Execute o seguinte comando **na sua máquina cliente** (ou seja, você **não** deve executar isso enquanto já estiver conectado via SSH à máquina do seu node - se estiver, **saia do SSH primeiro**):

```shell
ssh-keygen -t ed25519 -C "your_email@example.com"
```

Você verá o seguinte:

```
Generating public/private ed25519 key pair.
Enter file in which to save the key (/home/username/.ssh/id_ed25519):
```

Isso pergunta onde você gostaria de salvar seu arquivo de chave privada.
O SSH é compatível com o padrão fornecido e o usará automaticamente para você se você selecioná-lo.
No entanto, você tem a opção de alterá-lo para outra coisa se desejar.

::: tip NOTA
O caminho `/home/username/.ssh/id_ed25519` é apenas um exemplo, assumindo que seu nome de usuário é `username`.
Você provavelmente tem um nome de usuário diferente.
Sempre que você vir um caminho como o acima neste guia, substitua-o pelo caminho que seu sistema realmente imprime com seu nome de usuário real.
:::

Se você estiver confortável com a configuração padrão, simplesmente pressione `Enter`.

Caso contrário, digite o local desejado para a chave.
Deve ser um caminho absoluto (por exemplo, `/home/username/.ssh/rocketpool_key` no Linux, ou `/Users/username/.ssh/rocketpool_key` no OSX).
Pressione `Enter` quando terminar.

Após pressionar `Enter`, você verá:

```
Enter passphrase (empty for no passphrase):
```

**Esta será a senha para a própria chave privada**.
Sempre que você usar a chave para se conectar ao seu node, você precisará digitar esta senha primeiro.

::: danger AVISO
**Você não deve deixar isso em branco** - caso contrário, qualquer pessoa com o arquivo de chave SSH poderá usá-lo!
Escolha uma boa senha que você (e somente você) saberá.

Além disso, **não esqueça sua senha** - não há como recuperar esta senha se você a perder.
:::

Depois de terminar de digitar a senha, pressione `Enter`.
Ele pedirá que você a digite novamente para confirmação.

Depois disso, você verá algo como a seguinte saída:

```
Your identification has been saved in /home/username/.ssh/id_ed25519
Your public key has been saved in /home/username/.ssh/id_ed25519.pub
The key fingerprint is:
SHA256:CASbPZETiQ83lLhpUO2aoT05TxMVLwqiWtdsRtoPt4s your_email@example.com
The key's randomart image is:
+--[ED25519 256]--+
| .o*==..         |
|. +=O...         |
|..+B++o .        |
|..=.+X o         |
|.+.=+.O S        |
|o.B.oo + .       |
|.  = .  o        |
|    .  . .       |
|      E .        |
+----[SHA256]-----+
```

A primeira linha indica a localização da **chave privada**, que é chamada de `id_ed25519` por padrão (observe que ela não tem uma extensão de arquivo).
O Ubuntu carregará esta chave para você automaticamente quando você usar `ssh` se este arquivo de chave privada estiver no local padrão.

A segunda linha indica a localização da **chave pública**, que é chamada de `id_ed25519.pub` por padrão.
Precisaremos da chave pública para a próxima etapa.

::: tip NOTA
O Ubuntu _deveria_ carregar esta nova chave automaticamente.
No entanto, alguns sistemas (como máquinas macOS) não a carregarão automaticamente - você terá que instruí-lo a fazer isso com o seguinte comando **na sua máquina cliente**:

```shell
ssh-add $HOME/.ssh/id_ed25519
```

Note que este é o caminho da **chave privada** que geramos na etapa anterior, **não a chave pública**.
Substitua o caminho pelo que seu sistema imprimiu naquela etapa anterior.

Se você receber um erro dizendo que o `ssh-agent` não está em execução, inicie-o executando o seguinte comando **na sua máquina cliente**:

```shell
eval $(ssh-agent)
```

Se você não quiser digitar esses dois comandos toda vez que abrir o terminal, você pode criar um atalho para adicionar sua chave adicionando um `alias` ao seu arquivo `~/.bashrc`.

Abra o arquivo usando o editor de texto:

```shell
nano ~/.bashrc
```

Adicione esta linha ao final (assumindo que você usou o caminho padrão para a chave privada - atualize conforme necessário):

```shell
alias loadkey='ssh-add $HOME/.ssh/id_ed25519'
```

Salve e saia com `Ctrl+O` e `Enter`, depois `Ctrl+X`.
Em seguida, feche e abra seu terminal para que as alterações entrem em vigor.

Agora você pode digitar `loadkey` **na sua máquina cliente** para carregar a chave.
:::

### Adicionando a Chave Pública ao seu Node

Depois de ter seu par de chaves SSH, você pode agora adicionar a **chave pública** ao seu node.
Isso permitirá que você se conecte a ele via `ssh` usando a chave privada que você acabou de gerar, em vez do seu nome de usuário e senha.

Existem duas maneiras de fazer isso - se uma não funcionar, tente a outra:

<div className="p-3">
  <Tabs>
    <Tab label="Usando ssh-copy-id">
      **Nota**: se sua máquina cliente estiver executando Windows, `ssh-copy-id` ainda não está disponível.
      Por favor, siga as instruções na aba "Adicionando Manualmente a Chave".

      Execute o seguinte comando **na sua máquina cliente**:

      ```shell
      ssh-copy-id -i $HOME/.ssh/id_ed25519.pub username@node.ip.address
      ```

      Por exemplo, se meu nome de usuário no node fosse `staker` e o endereço IP do meu node fosse `192.168.1.10`, eu executaria o seguinte comando:

      ```shell
      ssh-copy-id -i $HOME/.ssh/id_ed25519.pub staker@192.168.1.10
      ```

      Você verá algumas mensagens como as seguintes:

      ```
      /usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/home/username/.ssh/id_ed25519.pub"
      /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
      /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
      ```

      Isso informa que ele está tentando fazer login com sua chave primeiro para ter certeza de que ela ainda não está lá.
      Depois que falhar ao fazer login, ele saberá que está OK adicionar a nova chave pública à máquina do node.

      Em seguida, ele pedirá a **senha do usuário na máquina do seu node**.
      (_Observe que esta **não é a senha da chave SSH**!_)

      Digite a senha do seu usuário e você verá a seguinte saída:

      ```
      Number of key(s) added: 1

      Now try logging into the machine with:   "ssh 'username@node.ip.address'"
      and check to make sure that only the key(s) you wanted were added.
      ```

      Isso significa que funcionou!
    </Tab>
    <Tab label="Adicionando Manualmente a Chave">
      Comece obtendo o conteúdo da **chave pública** - execute este comando **na sua máquina cliente**:

      - No macOS e Linux:

      ```shell
      cat ~/.ssh/id_ed25519.pub
      ```

      - No Windows (Prompt de Comando):

      ```shell
      type %USERPROFILE%\.ssh\id_ed25519.pub
      ```

      - No Windows (PowerShell):

      ```shell
      type $ENV:UserProfile\.ssh\id_ed25519.pub
      ```

      A saída será algo como isto:

      ```
      ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGUgU3a6mNjy3N1TyWOwY+VA/nifAeABl2Ch2yIl1bGa your_email@example.com
      ```

      Esta é sua **chave pública**.
      Copie esta saída e armazene-a em algum lugar conveniente - você precisará dela em um minuto.

      Em seguida, use `ssh` para se conectar ao seu node como você normalmente faria (usando o nome de usuário e senha do seu node).

      Depois de conectado ao seu node, execute os seguintes comandos:

      ```shell
      mkdir -p ~/.ssh
      nano ~/.ssh/authorized_keys
      ```

      O segundo comando abrirá um editor de texto para o arquivo usado para armazenar todas as chaves públicas em que a conta de usuário do seu node confia.

      Neste arquivo, cole a **chave pública** que você recuperou há algumas etapas usando o comando `cat` (a linha inteira começando com `ssh-ed25519`).

      Quando estiver pronto, salve o arquivo com `Ctrl+O` e `Enter`, depois pressione `Ctrl+X` para sair.

      Agora, saia do `ssh` executando o comando `exit` para retornar ao terminal da sua máquina cliente local.
    </Tab>

  </Tabs>
</div>

Agora você deve ser capaz de usar `ssh` no node como normalmente faria, mas agora não precisará digitar a senha da conta de usuário.

Em vez disso, você terá que digitar **a senha da sua chave privada SSH**.
Dependendo das configurações do seu sistema, você pode ter que fazer isso apenas uma vez por reinicialização, ou pode ter que fazer isso toda vez que usar a chave para se conectar ao seu node.

### Desabilitar Login via Senha

Mesmo que você tenha um par de chaves SSH configurado, seu node ainda permitirá que outras máquinas tentem fazer login usando o método de nome de usuário e senha.
Isso anula todo o propósito de usar chaves SSH em primeiro lugar, então o próximo passo é desabilitar isso.

::: danger NOTA
Você está prestes a modificar a configuração do servidor SSH.
Todas as suas sessões SSH **existentes** serão preservadas.
No entanto, se você cometer um erro, é possível que você não consiga mais criar **novas** sessões SSH e efetivamente se tranque para fora da máquina.

Para evitar isso, recomendamos fortemente que você crie **2 sessões SSH** para as próximas etapas - uma para editar coisas e testar, e uma como backup para que você possa reverter quaisquer alterações que causem problemas.
:::

Comece fazendo login na sua máquina usando `ssh` como de costume:

```shell
ssh user@your.node.ip.address
```

Como lembrete, **você deve fazer isso duas vezes em dois terminais separados para ter uma sessão de backup por precaução**.
Você pode ignorar a sessão de backup por enquanto - diremos quando você precisar dela.
Execute os seguintes comandos **apenas na primeira sessão**.

Abra o arquivo de configuração do servidor SSH:

```shell
sudo nano /etc/ssh/sshd_config
```

Como em todos os comandos que começam com `sudo`, isso solicitará a **senha da sua conta de usuário**.
Este é um arquivo grande, então você terá que navegar por ele usando as teclas de seta do seu teclado ou `Page Up` / `Page Down`.

Faça as seguintes alterações:

1. Descomente `#AuthorizedKeysFile` se estiver comentado (removendo o `#` na frente dele)
2. Altere `KbdInteractiveAuthentication yes` para `KbdInteractiveAuthentication no` e descomente (removendo o `#` na frente dele) - **observe que versões mais antigas do SSH chamam esta opção de `ChallengeResponseAuthentication` em vez de `KbdInteractiveAuthentication`**
3. Altere `PasswordAuthentication yes` para `PasswordAuthentication no` e descomente (removendo o `#` na frente dele)
4. Altere `PermitRootLogin yes` para `PermitRootLogin prohibit-password` a menos que já esteja definido assim e tenha um `#` na frente

Depois de terminar, salve com `Ctrl+O` e `Enter`, depois saia com `Ctrl+X`.

Por fim, execute `sudo sshd -T | grep -i passwordauthentication` e certifique-se de que imprime `passwordauthentication no`.
Se não imprimir, você pode precisar executar `sudo nano /etc/ssh/sshd_config.d/50-cloud-init.conf` e definir `PasswordAuthentication yes` para `PasswordAuthentication no` nesse arquivo também.
Salve e saia como antes, com `Ctrl+O` e `Enter`, depois `Ctrl+X`

Em seguida, reinicie o servidor SSH para que ele pegue as novas configurações:

```shell
sudo systemctl restart ssh.service
```

Depois disso, fazer login no SSH via nome de usuário e senha deve estar desabilitado.

::: warning NOTA
Neste ponto, você deve sair da sessão SSH e tentar fazer SSH de volta.
Se você conseguir fazer isso com sucesso, então sua configuração SSH ainda é válida!

Se você **não** conseguir voltar, então algo deu errado com sua configuração.
Use a sessão SSH de backup que você criou no início desta seção para modificar o arquivo `/etc/ssh/sshd_config`.

Tente encontrar o erro ou desfazer suas alterações, depois reinicie o servidor SSH usando `sudo systemctl restart sshd`.

Depois que ele for reiniciado, tente se conectar com SSH novamente no seu "outro" terminal.
Continue fazendo isso até que esteja funcionando novamente e você consiga se conectar com sucesso.
:::

### (Opcional) Habilitar Autenticação de Dois Fatores

A autenticação de dois fatores envolve exigir uma segunda medida de segurança além da sua senha ou chave SSH, geralmente em um dispositivo separado do seu primário.

Por exemplo, você pode estar familiarizado com fazer login em um site como uma exchange de cripto usando tanto uma senha quanto um código do Google Authenticator (ou um código SMS).
Este processo de dois passos é um exemplo de autenticação de dois fatores.

O SSH também pode ser configurado para exigir um código do Google Authenticator, o que significa que um atacante que de alguma forma comprometeu sua chave SSH e sua senha **ainda precisaria do dispositivo com o aplicativo autenticador nele** (presumivelmente seu telefone).
Isso adiciona uma camada extra de segurança ao seu sistema.

::: danger AVISO
Nós **recomendamos fortemente** que você abra um segundo terminal com uma conexão SSH ao seu node, só por precaução caso você configure algo errado.
Dessa forma, você terá um backup que ainda está conectado caso se tranque para fora, para que possa facilmente desfazer seus erros.

Se você **conseguir** se trancar para fora, você precisará acessar fisicamente seu node através de seu monitor e teclado locais para fazer login e reparar a configuração incorreta.
:::

Comece instalando o [Google Authenticator](https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&hl=en_US&gl=US) (ou um equivalente compatível) no seu telefone se você ainda não o tiver.
Para usuários do Android, considere [andOTP](https://play.google.com/store/apps/details?id=org.shadowice.flocke.andotp&hl=en_US&gl=US) que é uma alternativa de código aberto que suporta bloqueio por senha e backups convenientes.

Em seguida, instale o módulo Google Authenticator no seu node com este comando:

```shell
sudo apt install -y libpam-google-authenticator
```

Agora diga ao `PAM` (módulos de autenticação plugáveis) para usar este módulo.
Primeiro, abra o arquivo de configuração:

```shell
sudo nano /etc/pam.d/sshd
```

Encontre `@include common-auth` (deve estar no topo) e comente-o adicionando um `#` na frente, para que fique assim:

```
# Standard Un*x authentication.
#@include common-auth
```

Em seguida, adicione estas linhas ao topo do arquivo:

```shell
# Enable Google Authenticator
auth required pam_google_authenticator.so
```

Então salve e saia do arquivo com `Ctrl+O`, `Enter` e `Ctrl+X`.

Agora que o `PAM` sabe usar o Google Authenticator, o próximo passo é dizer ao `sshd` para usar o `PAM`.
Abra o arquivo de configuração do `sshd`:

```shell
sudo nano /etc/ssh/sshd_config
```

Agora altere a linha `KbdInteractiveAuthentication no` para `KbdInteractiveAuthentication yes` para que fique assim:

```
# Change to yes to enable challenge-response passwords (beware issues with
# some PAM modules and threads)
KbdInteractiveAuthentication yes
```

(Versões mais antigas do SSH chamam esta opção de `ChallengeResponseAuthentication` em vez de `KbdInteractiveAuthentication`.)

Adicione a seguinte linha ao final do arquivo, que indica ao `sshd` que ele precisa tanto de uma chave SSH quanto do código do Google Authenticator:

```shell
AuthenticationMethods publickey,keyboard-interactive:pam
```

Então salve e saia do arquivo com `Ctrl+O`, `Enter` e `Ctrl+X`.

Agora que o `sshd` está configurado, precisamos criar nossos códigos 2FA.
No seu terminal, execute:

```shell
google-authenticator
```

Primeiro, ele perguntará sobre tokens baseados em tempo.
Diga `y` para esta pergunta:

```
Do you want authentication tokens to be time-based: y
```

Agora você verá um grande código QR na sua tela; escaneie-o com seu aplicativo Google Authenticator para adicioná-lo.
Você também verá seu segredo e alguns códigos de backup assim:

```
Your new secret key is: IRG2TALMR5U2LK5VQ5AQIG3HA4
Your verification code is 282436
Your emergency scratch codes are:
  29778030
  86888537
  50553659
  41403052
  82649596
```

::: warning NOTA
Registre os códigos de backup de emergência em algum lugar seguro caso você precise fazer login na máquina mas não tenha seu aplicativo 2FA à mão.
Sem o aplicativo, você não poderá mais fazer SSH na máquina!
:::

Finalmente, ele perguntará sobre mais alguns parâmetros; os padrões recomendados são os seguintes:

```
Do you want me to update your "/<username>/.google_authenticator" file: y
Do you want to disallow multiple uses of the same authentication token: y
By default... < long story about time skew > ... Do you want to do so: n
Do you want to enable rate-limiting: y
```

Quando terminar, reinicie o `sshd` para que ele pegue as novas configurações:

```shell
sudo systemctl restart sshd
```

Quando você tentar fazer SSH no seu servidor com suas chaves SSH, agora você também deverá ser solicitado a fornecer um código de verificação 2FA, mas não uma senha.

## ESSENCIAL: Habilitar Atualizações Automáticas de Segurança

Os fornecedores de Sistemas Operacionais publicam rotineiramente atualizações e correções de segurança, por isso é importante que você mantenha seu sistema atualizado com os patches mais recentes.
A maneira mais fácil de fazer isso é habilitar atualizações automáticas.

Execute os seguintes comandos **na máquina do seu node**:

```shell
sudo apt update
sudo apt install -y unattended-upgrades update-notifier-common
```

Você pode alterar as configurações de atualização automática editando `/etc/apt/apt.conf.d/20auto-upgrades`:

```shell
sudo nano /etc/apt/apt.conf.d/20auto-upgrades
```

Este é um exemplo de configurações de atualização automática razoáveis:

```shell
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Unattended-Upgrade "1";
APT::Periodic::AutocleanInterval "7";
Unattended-Upgrade::Remove-Unused-Dependencies "true";
Unattended-Upgrade::Remove-New-Unused-Dependencies "true";

# This is the most important choice: auto-reboot.
# This should be fine since Rocketpool auto-starts on reboot.
Unattended-Upgrade::Automatic-Reboot "true";
Unattended-Upgrade::Automatic-Reboot-Time "02:00";
```

Quando terminar de adicionar suas alterações, salve com `Ctrl+O` e `Enter`, depois saia com `Ctrl+X`.

Depois, certifique-se de carregar as novas configurações:

```shell
sudo systemctl restart unattended-upgrades
```

## ESSENCIAL: Habilitar um Firewall

Em geral, sua máquina deve aceitar apenas tráfego de rede nas portas que seu cliente Execution, cliente Consensus e pilha Smartnode usam.
Para impor isso e prevenir qualquer tráfego inesperado ou indesejável, podemos instalar um **firewall** no node.

::: tip NOTA
Se você selecionou uma porta de cliente execution/consensus diferente durante a configuração do Rocketpool, você precisa editar as portas abaixo para refletir suas configurações.
:::

O Ubuntu vem com `ufw` instalado por padrão (o **f**ire**w**all **d**escomplicado), que é um utilitário conveniente para gerenciar as configurações de firewall do seu node.

Os seguintes comandos configurarão o `ufw` com uma boa configuração padrão para o seu Smartnode.
**Execute-os na máquina do seu node**.

Desabilite conexões a menos que sejam explicitamente permitidas por regras posteriores:

```shell
sudo ufw default deny incoming comment 'Deny all incoming traffic'
```

Permita SSH:

```shell
sudo ufw allow "22/tcp" comment 'Allow SSH'
```

Permita cliente execution (anteriormente referido como ETH1):

```shell
sudo ufw allow 30303/tcp comment 'Execution client port, standardized by Rocket Pool'
sudo ufw allow 30303/udp comment 'Execution client port, standardized by Rocket Pool'
```

Permita cliente consensus (anteriormente referido como ETH2):

```shell
sudo ufw allow 9001/tcp comment 'Consensus client port, standardized by Rocket Pool'
sudo ufw allow 9001/udp comment 'Consensus client port, standardized by Rocket Pool'
```

Se você executar o cliente lighthouse v4.5.0+, você pode usar o protocolo quic para reduzir a latência / aumentar a largura de banda, o protocolo quic usa lighthouse's --port + 1 para escutar mensagens quic por padrão: https://lighthouse-blog.sigmaprime.io/Quic,%20Networking.html

```shell
sudo ufw allow 8001/udp comment 'Consensus client port, standardised by Rocket Pool'
```

Finalmente, habilite o `ufw`:

```shell
sudo ufw enable
```

::: tip NOTA
Especialistas em `iptables` podem notar que o Docker ignora as configurações do `ufw`.
Estritamente falando, isso significa que, a menos que você esteja executando no modo Hybrid, você não precisa das regras de cliente Execution e Consensus.
Adicioná-las, no entanto, não tem desvantagem e garantirá que se você mudar para o modo Hybrid você não terá problemas de firewall.
:::

## (Opcional) Habilitar Proteção contra Força Bruta e DDoS

Para proteger seu servidor contra ataques DDoS e tentativas de conexão de força bruta, você pode instalar o `fail2ban`.
Este programa monitorará conexões recebidas e bloqueará endereços IP que tentam fazer login com credenciais incorretas repetidamente.

Consulte [este guia](https://github.com/imthenachoman/How-To-Secure-A-Linux-Server#application-intrusion-detection-and-prevention-with-fail2ban) para mais informações sobre prevenção de intrusão.

Execute os seguintes comandos **na máquina do seu node**:

Instale o serviço:

```shell
sudo apt install -y fail2ban
```

Em seguida, abra `/etc/fail2ban/jail.d/ssh.local`:

```shell
sudo nano /etc/fail2ban/jail.d/ssh.local
```

Adicione o seguinte conteúdo a ele:

```
[sshd]
enabled = true
banaction = ufw
port = 22
filter = sshd
logpath = %(sshd_log)s
maxretry = 5
```

Você pode alterar a configuração `maxretry`, que é o número de tentativas que permitirá antes de bloquear o endereço ofensor.

Quando terminar, salve e saia com `Ctrl+O` e `Enter`, depois `Ctrl+X`.

Finalmente, reinicie o serviço:

```shell
sudo systemctl restart fail2ban
```

E com isso, você acabou de melhorar muito a postura de segurança do seu node.
Parabéns!
