import ethereum_client_diversity from "./images/ethereum-client-diversity-aug-2025.png";

# 选择您的 ETH 客户端

Rocket Pool 的 Smartnode 安装程序可以将您的机器转换为完整的以太坊节点,因为它需要执行层和共识层客户端才能正常运行。

ETH1/ETH2 术语已被弃用。
在本指南的其余部分,这些链将被称为**执行层 (ETH1)** 和**信标链或共识层 (ETH2)**。

如果您已经在另一台机器上运行执行层和共识层客户端(例如,如果您已经在进行单独质押),那么请跳过本节,转到[使用外部客户端配置混合 Rocket Pool 节点](./install-modes#the-hybrid-configuration-with-external-clients)部分。

否则,请继续阅读以了解有关执行层和共识层客户端选择的更多信息。

::: warning 注意
截至 2025 年 8 月,信标链上的客户端分布大致如下:

<img src={ethereum_client_diversity} width="100%" height="auto" />

_数据来自 [https://clientdiversity.org](https://clientdiversity.org)_

获取关于验证者运行哪个共识客户端的数据是一个相对困难的问题,因为客户端不容易被识别。[https://clientdiversity.org](https://clientdiversity.org) 上的[数据方法](https://clientdiversity.org/methodology/)页面详细介绍了如何从不同来源获取数据。欢迎查看 [https://ethernodes.org/](https://ethernodes.org/) 作为额外的数据来源。

绝大多数节点运营者目前使用 Geth 作为执行层客户端,使用 Lighthouse 或 Prysm 作为共识层客户端。
为了支持执行层(原 ETH1)和信标链(原 ETH2)的健康,我们目前建议您考虑使用不同的客户端。
如果您想了解更多关于为什么均衡的客户端多样性对网络健康至关重要的信息,以下是一些相关文章:

[https://clientdiversity.org/#why](https://clientdiversity.org/#why)

[https://blog.ethereum.org/2020/08/21/validated-why-client-diversity-matters/](https://blog.ethereum.org/2020/08/21/validated-why-client-diversity-matters/)

[https://our.status.im/the-importance-of-client-diversity/](https://our.status.im/the-importance-of-client-diversity/)

[https://medium.com/prysmatic-labs/eth2-mainnet-incident-retrospective-f0338814340c](https://medium.com/prysmatic-labs/eth2-mainnet-incident-retrospective-f0338814340c)

[https://dankradfeist.de/ethereum/2022/03/24/run-the-majority-client-at-your-own-peril.html](https://dankradfeist.de/ethereum/2022/03/24/run-the-majority-client-at-your-own-peril.html)

[https://eth2book.info/bellatrix/part2/incentives/diversity](https://eth2book.info/bellatrix/part2/incentives/diversity/)
:::

对于想要快速启动和运行的用户,Smartnode 安装程序提供了 `Random Client` 选项,这可能是最佳选择。
对于有特定客户端选择的用户,我们提供在 Rocket Pool 安装过程中轻松选择的能力。
下面的选项有助于描述每个客户端,以便您在想要指定所需客户端时做出明智的决定。

## 执行层客户端

Rocket Pool 支持四种不同的执行层客户端:**Geth**、**Besu**、**Nethermind** 和 **Reth**。

运行执行层客户端涉及在您的机器上存储执行层区块链的副本。
它通过点对点通信与其他执行层客户端节点交互,以记录和验证新的区块和交易。
现在执行层和共识层已经合并,运行验证者**需要**完整的执行层客户端。

### Geth

[Geth](https://geth.ethereum.org/)(正式名称为 `Go Ethereum`)是以太坊协议的三个原始实现(与 C++ 和 Python 一起)之一。
它使用 Go 编写,完全开源,并在 GNU LGPL v3 许可下发布。

Geth 是全球最古老、使用最广泛的执行层客户端。
它以非常稳定和可靠而闻名。

它是多线程的,这意味着它可以利用您的整个 CPU。
其 RAM 使用量是可配置的,**主网最低约 4 GB**。
这使其适用于低功耗系统和高功耗系统。

::: warning 注意
Geth 需要定期**离线修剪**其数据库:其数据库会随着时间增长,并逐渐消耗所有可用磁盘空间,除非您在磁盘空间不足时进行修剪。
修剪频率取决于您的 SSD 大小。

有关修剪 Geth 的更多信息,请查看[修剪执行层客户端](./pruning)页面。
:::

### Besu

Hyperledger [Besu](https://besu.hyperledger.org/en/stable/) 是在 Apache 2.0 许可下开发的开源以太坊客户端,使用 [Java](https://en.wikipedia.org/wiki/Java_%28programming_language%29) 编写。
Besu 最令人兴奋的功能是使用 [Bonsai Tries](https://consensys.net/blog/news/bonsai-tries-a-big-update-for-small-state-storage-in-hyperledger-besu/) 进行状态存储。除了更好的性能特性外,Bonsai Tries 为 Besu 提供了两个有趣的优势:

1. Besu *不需要*修剪;在这方面它实际上是免维护的
2. Besu 能够访问区块链中的任何过去区块,尽管它是通过回退每个区块来实现的,因此到达很久以前的区块可能需要一些时间。

Besu 目前建议至少 **16 GB RAM**,尽管可以在 8 GB 下成功运行。

### Nethermind

[Nethermind](https://nethermind.io/nethermind-client/) 使用 [.NET Core](https://en.wikipedia.org/wiki/.NET) 编写。
它拥有执行层客户端中最快的同步速度,并具有丰富的配置选项集。
它专为节点运营者设计,并具有许多他们会觉得有用的功能。

与 Geth 一样,Nethermind 需要定期修剪其数据库。
但是,与 Geth 不同,Nethermind 的数据库[可以在保持在线的同时进行修剪](https://medium.com/nethermind-eth/netherminds-full-pruning-is-here-cutting-the-gordian-knot-5e3450f02de9)。
这意味着您不需要关闭客户端并依赖备用客户端来进行修剪。
但是,Nethermind 的在线修剪过程资源密集,因此运行低功耗节点的用户在此过程中可能会看到一些性能下降。

Nethermind 需要**至少 16GB RAM**,尽管更多更好。

::: tip 注意
Nethermind 需要定期修剪其数据库:其数据库会随着时间增长,并逐渐消耗所有可用磁盘空间,除非您在磁盘空间不足时进行修剪。
修剪频率取决于您的 SSD 大小。

但是,与 Geth 不同,Nethermind 在修剪时**保持在线**。
这使其成为节点的一个有吸引力的选择,因为它们在修剪期间不会有任何停机时间。

有关修剪 Nethermind 的更多信息,请查看[修剪执行层客户端](./pruning)页面。
:::

### Reth

[Reth](https://reth.rs/) 是使用 [Rust](https://www.rust-lang.org/) 编写的执行层客户端,使用 [Erigon 分阶段同步](https://erigon.substack.com/p/erigon-stage-sync-and-control-flows)架构。
Reth 从头开始设计,注重效率、性能和模块化。它在 Apache/MIT 许可下发布,由小型、抽象良好、经过充分测试和基准测试的包构建。这为开源开发者体验提供了良好的基础,并允许 Reth 的组件在其他项目中使用。

作为生态系统中最新的客户端,Reth 正在快速发展并获得采用。虽然 RAM 和 CPU 要求是灵活的,但最重要的要求是磁盘。我们建议使用优质的 [TLC 磁盘](https://gist.github.com/yorickdowne/f3a3e79a573bf35767cd002cc977b038)。
Reth 对于完整节点需要**至少 8 GB RAM**,对于存档节点需要 **16 GB RAM**。

### 客户端比较表

| 客户端     | 类型 | CPU 使用 | 最低 RAM 使用 | 同步时间 |
| ---------- | ---- | -------- | ------------- | -------- |
| Geth       | 完整 | 中等     | 4 GB          | 中等     |
| Besu       | 完整 | 中等     | 6 GB          | 慢       |
| Nethermind | 完整 | 中等     | 16 GB         | 快       |
| Reth       | 完整 | 中等     | 8 GB          | 快       |

## 共识层客户端

Rocket Pool 的安装程序自豪地支持五个当前可用的共识层客户端:**Lighthouse**、**Lodestar**、**Nimbus**、**Prysm** 和 **Teku**。

这些都是**完整客户端**,这意味着无论您选择哪个客户端,您都将为共识层网络的去中心化做出贡献。

这五个客户端都是低风险、低维护的,并且将从验证中产生几乎相同的总奖励。
它们在资源要求和功能方面略有不同,但您选择其中任何一个都不会出错。

默认情况下,Rocket Pool 安装程序将提供为您随机选择一个共识客户端。
这将有助于为网络的整体**多样性**做出贡献。
从安全角度来看,这很重要:如果一个客户端被大多数节点使用并遭受严重的错误或攻击,可能会导致所有这些节点失败,从而威胁整个信标链的稳定性。

### Lighthouse

[Lighthouse](https://lighthouse.sigmaprime.io/) 是由 [Sigma Prime](https://sigmaprime.io/) 维护的开源以太坊 2.0 客户端。
它实现了以太坊基金会研究团队定义的 [Ethereum 2.0 规范](https://github.com/ethereum/consensus-specs)。

Lighthouse 是一个前沿的分布式系统项目,实现了区块链研究前沿的技术;包括权益证明共识、并行交易执行和状态分离(分片)。

Lighthouse 与以太坊基金会没有官方关联,只要符合以太坊协议和周围社区的最佳利益,它将继续遵循其指导。

Lighthouse 使用 [Rust](https://www.rust-lang.org/) 实现,将保持对安全性和效率的关注。

### Lodestar

[Lodestar](https://lodestar.chainsafe.io/) 是由 [ChainSafe Systems](https://chainsafe.io/) 维护的第五个开源以太坊共识客户端。我们的旗舰产品是用于以太坊共识的生产级信标链和验证者客户端。我们的软件和工具作为研究人员和开发者的首选工具独树一帜,用于快速原型开发和浏览器使用。全球数百万开发者熟悉 Typescript,Lodestar 的高质量代码库是进入以太坊世界的绝佳入门。

Lodestar 也一直是以太坊轻客户端研究、标准化和实现的领导者。我们努力与其他客户端实现者、研究人员和开发者合作,展示浏览器直接从区块链使用无信任数据的重要性。

Lodestar 的特色在于其实现语言 [Typescript](https://www.typescriptlang.org/)。

### Nimbus

[Nimbus](https://nimbus.team/) 是以太坊 2.0 和以太坊 1.0 的客户端实现,在使用的资源方面力求尽可能轻量级。
这使其能够在嵌入式系统和资源受限的设备上表现良好。

但是,资源受限的硬件并不是 Nimbus 唯一擅长的。
其低资源消耗使得 Nimbus 可以轻松地与服务器上的其他工作负载一起运行(这对于希望降低服务器实例成本的质押者特别有价值)。

Nimbus 使用 [Nim](https://nim-lang.org/) 编写,由 [Status.im 团队](https://status.im/about/)维护。

### Prysm

[Prysm](https://docs.prylabs.network/docs/getting-started/#what-is-prysm) 项目是完全使用 [Go 编程语言](https://golang.org/)编写的以太坊 2.0 网络的全功能实现。

由 [Prysmatic Labs](https://prysmaticlabs.com/) 创建,Prysm 实现了官方的 [Ethereum 2.0 规范](https://github.com/ethereum/consensus-specs),这是以太坊生态系统中各个团队持续集体研究和开发工作的产物,包括[以太坊基金会](https://ethereum.org/)。

### Teku

[Teku](https://docs.teku.consensys.net/en/stable/)(以前称为 Artemis)是基于 [Java](https://en.wikipedia.org/wiki/Java_%28programming_language%29) 的以太坊共识客户端,旨在满足机构需求和安全要求。
PegaSys 是 [ConsenSys](https://consensys.net/) 的一个部门,致力于构建企业级客户端和工具,用于与核心以太坊平台交互。

Teku 在 Apache 2.0 许可下发布,使用 Java 编写,这是一种以成熟和普及著称的语言。

### 客户端比较表

| 客户端     | CPU 使用 | 最低 RAM 使用 | 同步时间           |
| ---------- | -------- | ------------- | ------------------ |
| Lighthouse | 中等     | 2 GB          | 使用检查点同步即时 |
| Lodestar   | 中等     | 4 GB          | 使用检查点同步即时 |
| Nimbus     | 低       | 0.75 GB       | 使用检查点同步即时 |
| Prysm      | 中等     | 2 GB          | 使用检查点同步即时 |
| Teku       | 中等     | 4 GB          | 使用检查点同步即时 |
