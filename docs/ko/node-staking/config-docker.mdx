import { Tab, Tabs } from "@rspress/core/theme";
import ECSelection from "./images/tui-ec-selection.png";
import tuiExternalEC from "./images/tui-external-ec.png";
import tuiLocalCC from "./images/tui-local-cc.png";
import tuiLocalGraffiti from "./images/tui-local-graffiti.png";
import tuiLocalCheckpoint from "./images/tui-local-checkpoint.png";
import tuiLocalDD from "./images/tui-local-dd.png";
import tuiExternalLH from "./images/tui-external-lh.png";
import tuiExternalGraffiti from "./images/tui-external-graffiti.png";
import tuiExternalDD from "./images/tui-external-dd.png";
import tuiExternalPrysm from "./images/tui-external-prysm.png";
import tuiExternalTeku from "./images/tui-external-teku.png";

# Smartnode 스택 구성하기 (Docker / Hybrid 모드)

완전한 Execution layer와 Consensus layer 클라이언트를 실행하는 것은 부담스러울 수 있습니다. 선택할 수 있는 여러 옵션이 있고 각각은 수많은 다양한 설정을 가지고 있습니다.
다행히도 Smartnode는 이 모든 복잡성을 숨기도록 설계되어 빠르고 쉽게 구성할 수 있으며, 원하는 경우 모든 것을 사용자 정의할 수 있는 자유를 제공합니다.

이 섹션에서는 **Docker 기반 설정** 또는 외부에서 관리되는 Execution 또는 Consensus 클라이언트에 연결하는 **Hybrid 설정**(예: 솔로 스테이킹을 위해 Smartnode 외부에서 관리하는 클라이언트)을 사용하는 경우 Smartnode를 구성하는 다양한 방법을 살펴보겠습니다.

::: warning 참고
Docker 없이 Native 모드를 사용하는 경우 [Native 구성 가이드](./config-native)를 참조하세요.
:::

구성하는 세 가지 방법이 있습니다:

- [마법사 UI](#마법사를-통한-구성)를 통해 - 가장 쉬운 방법입니다. 몇 가지 기본 질문만 하고 잘 테스트된 기본값을 사용합니다. 처음으로 `rocketpool service config`를 실행할 때 표시됩니다.
- [설정 관리자 UI](#설정-관리자를-통한-구성)를 통해 - Smartnode의 모든 설정에 액세스할 수 있어 원하는 만큼 모든 것을 사용자 정의할 수 있습니다.
- [명령줄](#명령줄을-통한-구성)을 통한 헤드리스 방식 - 헤드리스(비대화형) 환경에서 Smartnode를 실행하고 자동으로 구성해야 하는 사용자를 위한 옵션입니다.

위 목록에서 자세히 알아보고 싶은 모드를 선택하거나 아래의 각 옵션을 스크롤하십시오.

## 마법사를 통한 구성

구성 프로세스를 시작하려면 다음 명령을 실행하세요:

```shell
rocketpool service config
```

이렇게 하면 노드를 빠르고 쉽게 구성할 수 있는 터미널 기반 UI가 시작되며, 고급 사용자 정의를 위한 모든 설정에 대한 세밀한 제어도 선택적으로 제공됩니다.

::: tip 참고
이미 Smartnode를 구성한 경우 대신 [설정 관리자](#설정-관리자를-통한-구성)가 표시됩니다.
원하는 경우 거기에서 마법사를 다시 열 수 있으며 기존 설정이 모두 미리 선택됩니다.
:::

처음으로 구성 UI를 실행할 때(또는 나중에 마법사를 다시 실행하도록 선택한 경우) 다음과 같은 화면이 표시됩니다:

<img src="./images/tui-first-time.png" width="100%" height="auto" />

::: tip 팁
마법사를 사용하려면 **`방향키`(위/아래/왼쪽/오른쪽)를 눌러 버튼(선택 항목) 또는 텍스트 상자와 같은 것들 사이를 이동**하세요.
원하는 경우 `Tab`과 `Shift+Tab`을 사용할 수도 있습니다 - 동일한 기능을 수행합니다.

버튼의 경우 **현재 선택된 버튼이 녹색으로 강조 표시됩니다**.
검은색으로 표시된 버튼은 선택되지 않은 것입니다.
위 스크린샷에서 `Next`가 현재 선택되어 있고 `Quit`는 선택되지 않았습니다.

**`Enter` 또는 `Space`를 눌러 버튼을 선택**하세요. 마우스로 클릭하는 것과 유사합니다.

**`Escape`를 눌러 이전 대화 상자로 돌아가세요** 뭔가에 대해 마음이 바뀐 경우.
다양한 마법사 페이지를 진행하면서 유용하게 사용할 수 있습니다.

**언제든지 `Ctrl`을 누른 상태에서 `C`를 눌러 아무것도 저장하지 않고 마법사를 종료**할 수 있습니다.

예를 들어, 위 화면에서 `왼쪽` 및 `오른쪽` 방향키를 눌러 `Next`와 `Quit` 버튼 사이를 이동할 수 있습니다.

`Next`가 선택된 상태에서 `Enter`를 누르면 다음 화면으로 진행됩니다.
`Quit`가 선택된 상태에서 `Enter`를 누르면 저장하지 않고 마법사를 종료합니다.
:::

준비가 되면 `Next`를 누르세요.

### 네트워크 선택

다음 화면에서는 사용할 네트워크를 선택하라는 메시지가 표시됩니다:

<img src="./images/tui-network.png" width="100%" height="auto" />

`위` 및 `아래` 방향키(또는 `Tab` 및 `Shift+Tab`)로 다양한 선택 항목을 강조 표시할 수 있습니다.
선택 항목을 변경하면 오른쪽의 **Description** 상자에 각 옵션에 대한 간단한 설명이 표시됩니다.
이는 네트워크 선택뿐만 아니라 마법사의 모든 선택 기반 페이지에 적용되므로 이 스타일의 페이지를 자주 보게 됩니다.

무료로 얻을 수 있는 가짜 ETH와 RPL로 Hoodi 테스트 네트워크에서 Rocket Pool 노드를 실행하는 연습을 하고 싶다면 **Hoodi Testnet**을 선택하세요.

실제 보상을 얻기 위해 메인넷에서 실제 Rocket Pool 노드를 만들 준비가 되었다면 **Mainnet**을 선택하세요.

### 클라이언트 모드

클라이언트 모드에 대한 두 가지 옵션이 표시됩니다:

<img src="./images/tui-client-mode.png" width="100%" height="auto" />

**Locally Managed**(**"Docker 모드"**라고도 함)가 기본 선택입니다.
클라이언트 쌍이 아직 없고 Smartnode가 클라이언트를 관리하도록 하려면 이것을 사용하세요.
이것을 선택하면 Smartnode가 Execution & Consensus 클라이언트 쌍을 Docker 컨테이너로 생성, 구성 및 관리합니다.
걱정하지 마세요, 다음에 _어떤_ 클라이언트를 실행할지 선택할 수 있습니다.

**Externally Managed**(**"Hybrid 모드"**라고도 함)는 이미 다른 곳에서 수동으로 관리하는 Execution & Consensus 클라이언트 쌍이 있는 사용자에게 편리한 선택입니다.
이것을 선택하면 Smartnode는 단순히 기존 클라이언트에 연결하고 자체 클라이언트를 실행하지 않습니다.
예를 들어, 사용자는 현재 솔로 스테이킹에 사용하는 클라이언트에 연결할 수 있습니다. 이렇게 하면 두 개의 별도 클라이언트 사본이 필요하지 않습니다.

:::warning 참고
Execution-Consensus Layer 병합 이후, 이러한 모드를 혼합하여 사용할 수 _없습니다_(예: 로컬 Execution 클라이언트와 외부 관리 Consensus 클라이언트를 함께 사용할 수 없음).
모두 로컬 관리 또는 모두 외부 관리 중 하나를 선택해야 합니다.
:::

### Execution 클라이언트 설정

Execution 클라이언트를 관리하는 데 사용할 모드를 선택하고 아래의 해당 탭에서 단계를 따르세요:

<div className="p-3">
  <Tabs>
    <Tab label="Locally Managed">
      Smartnode가 Execution 클라이언트를 관리하도록 하려면 다음 화면에서 클라이언트를 선택하라는 메시지가 표시됩니다:

      <img src={ECSelection} width="100%" height="auto"/>

      각 옵션에 대한 설명은 [ETH 클라이언트 선택하기](/ko/node-staking/eth-clients#execution-clients) 섹션을 참조하세요.
      선택을 마쳤으면 아래의 해당 탭을 클릭하여 구성 방법을 알아보세요:

      **Geth**, **Besu** 또는 **Nethermind**를 선택하면 마법사가 모든 구성을 처리합니다.
      이 프로세스가 끝날 때 일부 매개변수를 수동으로 조정할 수 있지만, 사용하는 기본값은 노드 작동에 완전히 적합합니다.
      다음 섹션으로 진행할 수 있습니다.


      <p className="rspress-directive warning">
        <p className="rspress-directive-title">참고</p>
        **라우터의 포트 포워딩 설정에서 P2P 포트를 열어주세요**. TCP와 UDP 모두에서 **포트 30303**을 머신의 로컬 IP 주소로 포워딩하도록 구성하세요.
        이렇게 하면 다른 Consensus 클라이언트가 이를 발견하고 외부에서 통신할 수 있습니다. 이렇게 하면 Consensus 클라이언트가 빠르게 동기화되고 성능(따라서 보상)이 향상됩니다.

        각 라우터는 포트 포워딩 설정 방법이 다르므로 **라우터 설명서를 확인하여 포트 포워딩을 설정하는 방법을 알아보세요**.
      </p>

      <p className="rspress-directive warning">
        <p className="rspress-directive-title">참고</p>
        Smartnode는 자체 Docker 컨테이너에서 실행되므로 Docker의 내부 네트워크를 사용합니다.
        여기서는 `localhost` 또는 `127.0.0.1`과 같은 호스트명을 사용할 수 없습니다. Execution 클라이언트가 Smartnode와 동일한 머신에서 실행 중인 경우 대신 머신의 LAN IP 주소를 제공해야 합니다.
      </p>

      이제 Execution 클라이언트가 모두 설정되었습니다!
    </Tab>
    <Tab label="External">
      외부에서 관리되는 Execution 클라이언트의 경우 다음 화면에서 HTTP 기반 RPC (web3) API의 URL과 Websocket 기반 RPC API의 URL을 입력하라는 메시지가 표시됩니다:

      <img src={tuiExternalEC} width="100%" height="auto"/>

      Smartnode는 HTTP URL을 사용하여 통신하고 체인 상태 쿼리 및 트랜잭션 제출과 같은 블록체인 활동을 수행합니다.
      **클라이언트의 API 포트가 이미 활성화되어 있지 않고 Smartnode 머신에서 액세스할 수 없는 경우 지금 설정해야 합니다.**
      이에 대한 지침은 클라이언트마다 다릅니다. HTTP RPC 엔드포인트를 설정하는 방법은 클라이언트 문서를 참조하세요.

      Websocket URL은 자체 사용에 필요한 경우에만 관련이 있습니다. Smartnode는 이를 사용하지 않습니다.
      필요하지 않은 경우 비워둘 수 있습니다.

      <p className="rspress-directive warning">
        <p className="rspress-directive-title">참고</p>
        Smartnode는 자체 Docker 컨테이너에서 실행되므로 Docker의 내부 네트워크를 사용합니다.
        여기서는 `localhost` 또는 `127.0.0.1`과 같은 호스트명을 사용할 수 없습니다. 폴백 Execution 클라이언트가 Smartnode와 동일한 머신에서 실행 중인 경우 대신 머신의 LAN IP 주소를 제공해야 합니다.
      </p>

      폴백 Execution 클라이언트 선택이 만족스러우면 다음 단계로 진행하세요.
    </Tab>

  </Tabs>
</div>

### Consensus 클라이언트 설정

이제 Execution 클라이언트가 준비되었으므로 다음 작업은 Consensus 클라이언트를 설정하는 것입니다.
"모드"(로컬 또는 외부)는 이전에 Execution 클라이언트에 사용한 선택에서 상속됩니다.

아래 탭에서 이전에 선택한 모드를 선택하세요:

<div className="p-3">
  <Tabs>
    <Tab label="Locally Managed">
      Smartnode가 Consensus 클라이언트를 관리하도록 하려면 다음 화면에서 클라이언트를 선택하라는 메시지가 표시됩니다:

      <img src={tuiLocalCC} width="100%" height="auto"/>

      네트워크의 전반적인 건강과 다양성을 위한 **선호되는 선택**은 **Random (Recommended)** 선택이며, 이는 지원되는 네 가지 Consensus 클라이언트 중 하나를 무작위로 선택합니다.

      명시적인 클라이언트를 선택하려면 [ETH 클라이언트 선택하기](./eth-clients#eth2-clients) 섹션을 참조하여 각 옵션에 대한 설명을 확인하고 정보에 입각한 결정을 내리세요.


      <p className="rspress-directive warning">
        <p className="rspress-directive-title">참고</p>
        클라이언트 선택에 따라 경고가 표시되는 두 가지 조건이 있습니다:

        - 선택한 클라이언트가 현재 [과반수 클라이언트](https://clientdiversity.org/)인 경우, 이는 Beacon Chain의 검증자 대다수가 이를 사용하여 네트워크의 안정성을 위협한다는 의미입니다

        - 선택한 클라이언트가 현재 사용 중인 하드웨어에 비해 **리소스를 너무 많이 사용**하는 경우

        선택한 클라이언트에 대해 이러한 경우 중 하나라도 해당되면 경고가 표시되고 다른 클라이언트를 선택하라는 메시지가 표시됩니다.
        선택한 클라이언트를 계속 사용할 수 있는 옵션이 있지만 그렇게 하는 위험을 인식해야 합니다.
      </p>

      선택을 마쳤거나 무작위 클라이언트가 할당되면 아래의 해당 탭을 클릭하여 구성 방법을 알아보세요:

      <div className="p-3">
        <Tabs>
          <Tab label="Lighthouse">
            Lighthouse 구성의 첫 번째 옵션은 검증자의 **graffiti** 메시지에 대해 묻습니다:

            <img src={tuiLocalGraffiti} width="100%" height="auto"/>

            이것은 Beacon Chain에서 제안하는 모든 블록에 첨부할 수 있는 선택적 사용자 정의 메시지입니다.
            메시지는 영원히 보존되므로 흔적을 남기는 재미있는 작은 방법이라고 생각하세요!

            **graffiti의 최대 길이는 16자입니다.**

            오늘날 검증자가 Graffiti에 무엇을 사용하는지 몇 가지 예를 보려면 [여기를 살펴보세요](https://beaconcha.in/blocks).

            다음은 **Checkpoint Sync**를 활성화하거나 비활성화하는 옵션입니다:

            <img src={tuiLocalCheckpoint} width="100%" height="auto"/>

            Lighthouse는 신뢰하는 기존 Beacon Node에 연결하여 Beacon Chain 네트워크의 최신 블록에 즉시 동기화할 수 있는 기능이 있습니다.
            이는 시간이 걸리지 않고(기존 동기화는 며칠이 걸릴 수 있음) 일부 보안 이점이 있기 때문에 기존 동기화보다 선호됩니다.
            궁금하다면 [체크포인트 동기화에 대한 문서](https://lighthouse-book.sigmaprime.io/checkpoint-sync.html)를 살펴보세요.

            REST API에 대한 액세스를 제공하는 모든 Beacon Node의 URL을 여기에 입력할 수 있습니다.

            사용하려면 [아래의 Checkpoint Syncing 섹션](#beacon-chain-checkpoint-syncing)을 참조하세요.

            마지막 질문은 Doppelgänger Protection을 활성화할지 묻습니다:

            <img src={tuiLocalDD} width="100%" height="auto"/>

            Lighthouse는 [Doppelgänger Detection](https://lighthouse-book.sigmaprime.io/validator-doppelganger.html)이라는 기능을 지원합니다.
            간단히 말해서, 이 기능은 Lighthouse의 Validator Client가 재시작된 후 **의도적으로** 몇 가지 증명을 놓칩니다. 이 동안 검증자 키를 사용하여 증명이 여전히 네트워크로 전송되는지 확인합니다.

            이상적으로는 증명이 없어야 합니다(즉, 다른 머신이 검증자 키를 연결하여 실행되고 있지 않음).
            짧은 대기 기간 후 Lighthouse는 정상적으로 검증을 시작합니다.

            _그러나_ 검증자 키를 연결하여 실행 중인 _다른_ 머신이 _있는_ 경우 Lighthouse는 즉시 종료되고 로그 파일에 오류 메시지를 발행합니다.
            그 이유는 증명도 시작하면 **이중 증명**을 시작하게 되며 이는 **슬래싱 가능한 위반**이기 때문입니다.
            슬래싱되면 검증자가 Beacon 체인에서 강제로 종료되고 상당한 양의 ETH가 페널티로 부과됩니다.

            대부분의 경우 doppelgänger 감지는 클라이언트를 재시작한 후 몇 가지 놓친 증명만 발생합니다.
            그러나 검증자를 새 머신으로 이동하거나 새 Beacon 클라이언트로 변경하는 상황에서는 **doppelgänger 감지가 실수로 이중 증명을 하여 슬래싱되는 것을 방지할 수 있습니다**.

            minipool에 대한 저렴한 보험이라고 생각하세요. 재시작할 때마다 사소한 이익을 놓치겠지만, 실수로 두 곳에서 키를 실행하여 슬래싱되지 않을 것이라고 상당히 확신할 수 있습니다.

            버전 4.5.0부터 Lighthouse는 [QUIC 프로토콜](https://en.wikipedia.org/wiki/QUIC)을 사용하여 보다 효율적인 방식으로 P2P 연결을 설정하는 옵션이 있습니다. 이 기능을 사용하려면 ETH2 설정에서 "P2P QUIC port" 필드를 추가로 정의하고 라우터의 포트 포워딩 설정에서 노드로 포워딩해야 합니다. 기본 P2P QUIC 포트는 8001(UDP)입니다. 노드에서 이미 사용 중인 포트(또는 폴백/테스트넷 노드)와 충돌하지 않도록 하세요. 또한 노드에서 방화벽을 사용하는 경우 동일한 포트가 열려 있는지 확인하세요(`ufw status` 확인).
            QUIC 구성이 작동하는지 확인하려면 `docker run --network rocketpool_net curlimages/curl http://eth2:9100/metrics | grep libp2p_peers_multi`를 실행할 때 `libp2p_quic_peers` 뒤에 두 자리 숫자가 표시되어야 합니다.

          </Tab>
          <Tab label="Nimbus">
            Nimbus 구성의 첫 번째 옵션은 검증자의 **graffiti** 메시지에 대해 묻습니다:

            <img src={tuiLocalGraffiti} width="100%" height="auto"/>

            이것은 Beacon Chain에서 제안하는 모든 블록에 첨부할 수 있는 선택적 사용자 정의 메시지입니다.
            메시지는 영원히 보존되므로 흔적을 남기는 재미있는 작은 방법이라고 생각하세요!

            **graffiti의 최대 길이는 16자입니다.**

            오늘날 검증자가 Graffiti에 무엇을 사용하는지 몇 가지 예를 보려면 [여기를 살펴보세요](https://beaconcha.in/blocks).

            다음은 **Checkpoint Sync**를 활성화하거나 비활성화하는 옵션입니다:

            <img src={tuiLocalCheckpoint} width="100%" height="auto"/>

            Nimbus는 신뢰하는 기존 Beacon Node에 연결하여 Beacon Chain 네트워크의 최신 블록에 즉시 동기화할 수 있는 기능이 있습니다.
            이는 시간이 걸리지 않고(기존 동기화는 며칠이 걸릴 수 있음) 일부 보안 이점이 있기 때문에 기존 동기화보다 선호됩니다.
            궁금하다면 [체크포인트 동기화에 대한 문서](https://nimbus.guide/trusted-node-sync.html)를 살펴보세요.

            REST API에 대한 액세스를 제공하는 모든 Beacon Node의 URL을 여기에 입력할 수 있습니다.

            사용하려면 [아래의 Checkpoint Syncing 섹션](#beacon-chain-checkpoint-syncing)을 참조하세요.

            마지막 질문은 Doppelgänger Protection을 활성화할지 묻습니다:

            <img src={tuiLocalDD} width="100%" height="auto"/>

            Nimbus는 [Doppelgänger Protection](https://nimbus.guide/faq.html#why-does-my-validator-miss-two-epochs-of-attestations-after-restarting)이라는 기능을 지원합니다.
            간단히 말해서, 이 기능은 Nimbus가 재시작된 후 **의도적으로** 몇 가지 증명을 놓칩니다. 이 동안 검증자 키를 사용하여 증명이 여전히 네트워크로 전송되는지 확인합니다.

            이상적으로는 증명이 없어야 합니다(즉, 다른 머신이 검증자 키를 연결하여 실행되고 있지 않음).
            짧은 대기 기간 후 Nimbus는 정상적으로 검증을 시작합니다.

            _그러나_ 검증자 키를 연결하여 실행 중인 _다른_ 머신이 _있는_ 경우 Nimbus는 즉시 종료되고 로그 파일에 오류 메시지를 발행합니다.
            그 이유는 증명도 시작하면 **이중 증명**을 시작하게 되며 이는 **슬래싱 가능한 위반**이기 때문입니다.
            슬래싱되면 검증자가 Beacon 체인에서 강제로 종료되고 상당한 양의 ETH가 페널티로 부과됩니다.

            대부분의 경우 doppelgänger 감지는 클라이언트를 재시작한 후 몇 가지 놓친 증명만 발생합니다.
            그러나 검증자를 새 머신으로 이동하거나 새 Beacon 클라이언트로 변경하는 상황에서는 **doppelgänger 감지가 실수로 이중 증명을 하여 슬래싱되는 것을 방지할 수 있습니다**.

            minipool에 대한 저렴한 보험이라고 생각하세요. 재시작할 때마다 사소한 이익을 놓치겠지만, 실수로 두 곳에서 키를 실행하여 슬래싱되지 않을 것이라고 상당히 확신할 수 있습니다.

          </Tab>
          <Tab label="Prysm">
            Prysm 구성의 첫 번째 옵션은 검증자의 **graffiti** 메시지에 대해 묻습니다:

            <img src={tuiLocalGraffiti} width="100%" height="auto"/>

            이것은 Beacon Chain에서 제안하는 모든 블록에 첨부할 수 있는 선택적 사용자 정의 메시지입니다.
            메시지는 영원히 보존되므로 흔적을 남기는 재미있는 작은 방법이라고 생각하세요!

            **graffiti의 최대 길이는 16자입니다.**

            오늘날 검증자가 Graffiti에 무엇을 사용하는지 몇 가지 예를 보려면 [여기를 살펴보세요](https://beaconcha.in/blocks).

            다음은 **Checkpoint Sync**를 활성화하거나 비활성화하는 옵션입니다:

            <img src={tuiLocalCheckpoint} width="100%" height="auto"/>

            Prysm은 신뢰하는 기존 Beacon Node에 연결하여 Beacon Chain 네트워크의 최신 블록에 즉시 동기화할 수 있는 기능이 있습니다.
            이는 시간이 걸리지 않고(기존 동기화는 며칠이 걸릴 수 있음) 일부 보안 이점이 있기 때문에 기존 동기화보다 선호됩니다.
            궁금하다면 [체크포인트 동기화에 대한 문서](https://docs.prylabs.network/docs/prysm-usage/checkpoint-sync)를 살펴보세요.

            REST API에 대한 액세스를 제공하는 모든 Beacon Node의 URL을 여기에 입력할 수 있습니다.

            사용하려면 [아래의 Checkpoint Syncing 섹션](#beacon-chain-checkpoint-syncing)을 참조하세요.

            마지막 질문은 Doppelgänger Protection을 활성화할지 묻습니다:

            <img src={tuiLocalDD} width="100%" height="auto"/>

            Prysm은 Doppelgänger Protection이라는 기능을 지원합니다.
            간단히 말해서, 이 기능은 Prysm의 Validator Client가 재시작된 후 **의도적으로** 몇 가지 증명을 놓칩니다. 이 동안 검증자 키를 사용하여 증명이 여전히 네트워크로 전송되는지 확인합니다.

            이상적으로는 증명이 없어야 합니다(즉, 다른 머신이 검증자 키를 연결하여 실행되고 있지 않음).
            짧은 대기 기간 후 Prysm은 정상적으로 검증을 시작합니다.

            _그러나_ 검증자 키를 연결하여 실행 중인 _다른_ 머신이 _있는_ 경우 Prysm은 즉시 종료되고 로그 파일에 오류 메시지를 발행합니다.
            그 이유는 증명도 시작하면 **이중 증명**을 시작하게 되며 이는 **슬래싱 가능한 위반**이기 때문입니다.
            슬래싱되면 검증자가 Beacon 체인에서 강제로 종료되고 상당한 양의 ETH가 페널티로 부과됩니다.

            대부분의 경우 doppelgänger 감지는 클라이언트를 재시작한 후 몇 가지 놓친 증명만 발생합니다.
            그러나 검증자를 새 머신으로 이동하거나 새 Beacon 클라이언트로 변경하는 상황에서는 **doppelgänger 감지가 실수로 이중 증명을 하여 슬래싱되는 것을 방지할 수 있습니다**.

            minipool에 대한 저렴한 보험이라고 생각하세요. 재시작할 때마다 사소한 이익을 놓치겠지만, 실수로 두 곳에서 키를 실행하여 슬래싱되지 않을 것이라고 상당히 확신할 수 있습니다.

          </Tab>
          <Tab label="Teku">
            Teku 구성의 첫 번째 옵션은 검증자의 **graffiti** 메시지에 대해 묻습니다:

            <img src={tuiLocalGraffiti} width="100%" height="auto"/>

            이것은 Beacon Chain에서 제안하는 모든 블록에 첨부할 수 있는 선택적 사용자 정의 메시지입니다.
            메시지는 영원히 보존되므로 흔적을 남기는 재미있는 작은 방법이라고 생각하세요!

            **graffiti의 최대 길이는 16자입니다.**

            오늘날 검증자가 Graffiti에 무엇을 사용하는지 몇 가지 예를 보려면 [여기를 살펴보세요](https://beaconcha.in/blocks).

            마지막 질문은 **Checkpoint Sync**를 활성화하거나 비활성화하는 옵션입니다:

            <img src={tuiLocalCheckpoint} width="100%" height="auto"/>

            Teku는 신뢰하는 기존 Beacon Node에 연결하여 Beacon Chain 네트워크의 최신 블록에 즉시 동기화할 수 있는 기능이 있습니다.
            이는 시간이 걸리지 않고(기존 동기화는 며칠이 걸릴 수 있음) 일부 보안 이점이 있기 때문에 기존 동기화보다 선호됩니다.
            궁금하다면 [체크포인트 동기화에 대한 문서](https://docs.teku.consensys.net/en/latest/HowTo/Get-Started/Checkpoint-Start/)를 살펴보세요.

            REST API에 대한 액세스를 제공하는 모든 Beacon Node의 URL을 여기에 입력할 수 있습니다.

            사용하려면 [아래의 Checkpoint Syncing 섹션](#beacon-chain-checkpoint-syncing)을 참조하세요.
          </Tab>
          <Tab label="Lodestar">
            Lodestar 구성의 첫 번째 옵션은 검증자의 **graffiti** 메시지에 대해 묻습니다:

            <img src={tuiLocalGraffiti} width="100%" height="auto"/>

            이것은 Beacon Chain에서 제안하는 모든 블록에 첨부할 수 있는 선택적 사용자 정의 메시지입니다.
            메시지는 영원히 보존되므로 흔적을 남기는 재미있는 작은 방법이라고 생각하세요!

            **graffiti의 최대 길이는 16자입니다.**

            오늘날 검증자가 Graffiti에 무엇을 사용하는지 몇 가지 예를 보려면 [여기를 살펴보세요](https://beaconcha.in/blocks).

            다음은 **Checkpoint Sync**를 활성화하거나 비활성화하는 옵션입니다:

            <img src={tuiLocalCheckpoint} width="100%" height="auto"/>

            Lodestar는 신뢰하는 기존 Beacon Node에 연결하여 Beacon Chain 네트워크의 최신 블록에 즉시 동기화할 수 있는 기능이 있습니다.
            이는 시간이 걸리지 않고(기존 동기화는 며칠이 걸릴 수 있음) 일부 보안 이점이 있기 때문에 기존 동기화보다 선호됩니다.
            궁금하다면 [체크포인트 동기화에 대한 문서](https://chainsafe.github.io/lodestar/run/beacon-management/starting-a-node#checkpoint-sync)를 살펴보세요.

            REST API에 대한 액세스를 제공하는 모든 Beacon Node의 URL을 여기에 입력할 수 있습니다.

            사용하려면 [아래의 Checkpoint Syncing 섹션](#beacon-chain-checkpoint-syncing)을 참조하세요.

            마지막 질문은 Doppelgänger Protection을 활성화할지 묻습니다:

            <img src={tuiLocalDD} width="100%" height="auto"/>

            Lodestar는 Doppelgänger Detection이라는 기능을 지원합니다.
            간단히 말해서, 이 기능은 Lodestar의 Validator Client가 재시작된 후 **의도적으로** 몇 가지 증명을 놓칩니다. 이 동안 검증자 키를 사용하여 증명이 여전히 네트워크로 전송되는지 확인합니다.

            이상적으로는 증명이 없어야 합니다(즉, 다른 머신이 검증자 키를 연결하여 실행되고 있지 않음).
            짧은 대기 기간 후 Lodestar는 정상적으로 검증을 시작합니다.

            _그러나_ 검증자 키를 연결하여 실행 중인 _다른_ 머신이 _있는_ 경우 Lodestar는 즉시 종료되고 로그 파일에 오류 메시지를 발행합니다.
            그 이유는 증명도 시작하면 **이중 증명**을 시작하게 되며 이는 **슬래싱 가능한 위반**이기 때문입니다.
            슬래싱되면 검증자가 Beacon 체인에서 강제로 종료되고 상당한 양의 ETH가 페널티로 부과됩니다.

            대부분의 경우 doppelgänger 감지는 클라이언트를 재시작한 후 몇 가지 놓친 증명만 발생합니다.
            그러나 검증자를 새 머신으로 이동하거나 새 Beacon 클라이언트로 변경하는 상황에서는 **doppelgänger 감지가 실수로 이중 증명을 하여 슬래싱되는 것을 방지할 수 있습니다**.

            minipool에 대한 저렴한 보험이라고 생각하세요. 재시작할 때마다 사소한 이익을 놓치겠지만, 실수로 두 곳에서 키를 실행하여 슬래싱되지 않을 것이라고 상당히 확신할 수 있습니다.

          </Tab>
        </Tabs>
      </div>

      <p className="rspress-directive warning">
        <p className="rspress-directive-title">참고</p>
        **라우터의 포트 포워딩 설정에서 P2P 포트를 열어주세요**. TCP와 UDP 모두에서 **포트 9001**을 머신의 로컬 IP 주소로 포워딩하도록 구성하세요.
        이렇게 하면 다른 Consensus 클라이언트가 이를 발견하고 외부에서 통신할 수 있습니다. 이렇게 하면 Consensus 클라이언트가 빠르게 동기화되고 성능(따라서 보상)이 향상됩니다.

        각 라우터는 포트 포워딩 설정 방법이 다르므로 **라우터 설명서를 확인하여 포트 포워딩을 설정하는 방법을 알아보세요**
      </p>
    </Tab>
    <Tab label="Externally Managed">
      각 Consensus 클라이언트는 약간 다른 동작을 하기 때문에 Smartnode는 외부에서 사용 중인 클라이언트를 알아야 그에 따라 자체 동작을 조정할 수 있습니다.
      다음 화면의 목록에서 가지고 있는 클라이언트를 선택하는 것으로 시작하세요:

      <img src="./images/tui-external-cc.png" width="100%" height="auto"/>


      <p className="rspress-directive warning">
        <p className="rspress-directive-title">참고</p>
        현재 **Nimbus**는 독립형 Validator Container(VC)로 아직 실행할 수 없기 때문에 External 모드와 호환되지 않습니다.
        클라이언트가 이 기능을 지원하면 여기 목록에 추가됩니다.
      </p>

      아래 탭에서 클라이언트를 선택하여 구성을 완료하는 방법을 알아보세요.

      <div className="p-3">
        <Tabs>
          <Tab label="Lighthouse">
            Lighthouse Beacon Node의 API URL을 지정하는 것으로 시작하세요:

            <img src={tuiExternalLH} width="100%" height="auto"/>

            Smartnode는 HTTP URL을 사용하여 통신하고 체인 상태 쿼리 및 메시지 제출과 같은 블록체인 활동을 수행합니다.
            **API 포트가 이미 활성화되어 있지 않고 Smartnode 머신에서 액세스할 수 없는 경우 지금 설정해야 합니다.**
            이를 수행하는 방법은 [Lighthouse 문서](https://lighthouse-book.sigmaprime.io/api-bn.html)를 참조하세요.

            <p className="rspress-directive warning">
              <p className="rspress-directive-title">참고</p>
              Smartnode는 자체 Docker 컨테이너에서 실행되므로 Docker의 내부 네트워크를 사용합니다.
              여기서는 `localhost` 또는 `127.0.0.1`과 같은 호스트명을 사용할 수 없습니다. 클라이언트가 Smartnode와 동일한 머신에서 실행 중인 경우 대신 머신의 LAN IP 주소를 제공해야 합니다.
            </p>


            다음으로 검증자의 **graffiti** 메시지에 대해 묻습니다:

            <img src={tuiExternalGraffiti} width="100%" height="auto"/>

            이것은 Beacon Chain에서 제안하는 모든 블록에 첨부할 수 있는 선택적 사용자 정의 메시지입니다.
            메시지는 영원히 보존되므로 흔적을 남기는 재미있는 작은 방법이라고 생각하세요!

            **graffiti의 최대 길이는 16자입니다.**

            오늘날 검증자가 Graffiti에 무엇을 사용하는지 몇 가지 예를 보려면 [여기를 살펴보세요](https://beaconcha.in/blocks).

            마지막 질문은 Doppelgänger Protection을 활성화할지 묻습니다:

            <img src={tuiExternalDD} width="100%" height="auto"/>

            Lighthouse는 [Doppelgänger Detection](https://lighthouse-book.sigmaprime.io/validator-doppelganger.html)이라는 기능을 지원합니다.
            간단히 말해서, 이 기능은 Lighthouse의 Validator Client가 재시작된 후 **의도적으로** 몇 가지 증명을 놓칩니다. 이 동안 검증자 키를 사용하여 증명이 여전히 네트워크로 전송되는지 확인합니다.

            이상적으로는 증명이 없어야 합니다(즉, 다른 머신이 검증자 키를 연결하여 실행되고 있지 않음).
            짧은 대기 기간 후 Lighthouse는 정상적으로 검증을 시작합니다.

            _그러나_ 검증자 키를 연결하여 실행 중인 _다른_ 머신이 _있는_ 경우 Lighthouse는 즉시 종료되고 로그 파일에 오류 메시지를 발행합니다.
            그 이유는 증명도 시작하면 **이중 증명**을 시작하게 되며 이는 **슬래싱 가능한 위반**이기 때문입니다.
            슬래싱되면 검증자가 Beacon 체인에서 강제로 종료되고 상당한 양의 ETH가 페널티로 부과됩니다.

            대부분의 경우 doppelgänger 감지는 클라이언트를 재시작한 후 몇 가지 놓친 증명만 발생합니다.
            그러나 검증자를 새 머신으로 이동하거나 새 Beacon 클라이언트로 변경하는 상황에서는 **doppelgänger 감지가 실수로 이중 증명을 하여 슬래싱되는 것을 방지할 수 있습니다**.

            minipool에 대한 저렴한 보험이라고 생각하세요. 재시작할 때마다 사소한 이익을 놓치겠지만, 실수로 두 곳에서 키를 실행하여 슬래싱되지 않을 것이라고 상당히 확신할 수 있습니다.

          </Tab>
          <Tab label="Prysm">
            Prysm Beacon Node의 API URL과 JSON-RPC API URL을 지정하는 것으로 시작하세요:

            <img src={tuiExternalPrysm} width="100%" height="auto"/>

            Smartnode는 HTTP URL을 사용하여 통신하고 체인 상태 쿼리 및 메시지 제출과 같은 블록체인 활동을 수행합니다.
            Prysm Validator Client에 JSON-RPC URL을 준비하여 Beacon Node와 통신할 수 있도록 합니다. _Prysm의 Validator Client는 현재 HTTP API를 통해 작동할 수 없기 때문입니다._

            **API 포트가 이미 활성화되어 있지 않고 Smartnode 머신에서 액세스할 수 없는 경우 지금 설정해야 합니다.**
            이를 수행하는 방법은 [Prysm 문서](https://docs.prylabs.network/docs/prysm-usage/parameters)를 참조하세요.
            **`grpc-gateway` _및_ `rpc-host`를 활성화해야 합니다.**

            <p className="rspress-directive warning">
              <p className="rspress-directive-title">참고</p>
              Smartnode는 자체 Docker 컨테이너에서 실행되므로 Docker의 내부 네트워크를 사용합니다.
              여기서는 `localhost` 또는 `127.0.0.1`과 같은 호스트명을 사용할 수 없습니다. 클라이언트가 Smartnode와 동일한 머신에서 실행 중인 경우 대신 머신의 LAN IP 주소를 제공해야 합니다.
            </p>


            다음으로 검증자의 **graffiti** 메시지에 대해 묻습니다:

            <img src={tuiExternalGraffiti} width="100%" height="auto"/>

            이것은 Beacon Chain에서 제안하는 모든 블록에 첨부할 수 있는 선택적 사용자 정의 메시지입니다.
            메시지는 영원히 보존되므로 흔적을 남기는 재미있는 작은 방법이라고 생각하세요!

            **graffiti의 최대 길이는 16자입니다.**

            오늘날 검증자가 Graffiti에 무엇을 사용하는지 몇 가지 예를 보려면 [여기를 살펴보세요](https://beaconcha.in/blocks).

            마지막 질문은 Doppelgänger Protection을 활성화할지 묻습니다:

            <img src={tuiExternalDD} width="100%" height="auto"/>

            Prysm은 Doppelgänger Protection이라는 기능을 지원합니다.
            간단히 말해서, 이 기능은 Prysm의 Validator Client가 재시작된 후 **의도적으로** 몇 가지 증명을 놓칩니다. 이 동안 검증자 키를 사용하여 증명이 여전히 네트워크로 전송되는지 확인합니다.

            이상적으로는 증명이 없어야 합니다(즉, 다른 머신이 검증자 키를 연결하여 실행되고 있지 않음).
            짧은 대기 기간 후 Prysm은 정상적으로 검증을 시작합니다.

            _그러나_ 검증자 키를 연결하여 실행 중인 _다른_ 머신이 _있는_ 경우 Prysm은 즉시 종료되고 로그 파일에 오류 메시지를 발행합니다.
            그 이유는 증명도 시작하면 **이중 증명**을 시작하게 되며 이는 **슬래싱 가능한 위반**이기 때문입니다.
            슬래싱되면 검증자가 Beacon 체인에서 강제로 종료되고 상당한 양의 ETH가 페널티로 부과됩니다.

            대부분의 경우 doppelgänger 감지는 클라이언트를 재시작한 후 몇 가지 놓친 증명만 발생합니다.
            그러나 검증자를 새 머신으로 이동하거나 새 Beacon 클라이언트로 변경하는 상황에서는 **doppelgänger 감지가 실수로 이중 증명을 하여 슬래싱되는 것을 방지할 수 있습니다**.

            minipool에 대한 저렴한 보험이라고 생각하세요. 재시작할 때마다 사소한 이익을 놓치겠지만, 실수로 두 곳에서 키를 실행하여 슬래싱되지 않을 것이라고 상당히 확신할 수 있습니다.

          </Tab>
          <Tab label="Teku">
            Teku Beacon Node의 API URL을 지정하는 것으로 시작하세요:

            <img src={tuiExternalTeku} width="100%" height="auto"/>

            Smartnode는 HTTP URL을 사용하여 통신하고 체인 상태 쿼리 및 메시지 제출과 같은 블록체인 활동을 수행합니다.
            **API 포트가 이미 활성화되어 있지 않고 Smartnode 머신에서 액세스할 수 없는 경우 지금 설정해야 합니다.**
            이를 수행하는 방법은 [Teku 문서](https://docs.teku.consensys.net/en/latest/Reference/CLI/CLI-Syntax/#rest-api-enabled)를 참조하세요.


            <p className="rspress-directive warning">
              <p className="rspress-directive-title">참고</p>
              Smartnode는 자체 Docker 컨테이너에서 실행되므로 Docker의 내부 네트워크를 사용합니다.
              여기서는 `localhost` 또는 `127.0.0.1`과 같은 호스트명을 사용할 수 없습니다. 클라이언트가 Smartnode와 동일한 머신에서 실행 중인 경우 대신 머신의 LAN IP 주소를 제공해야 합니다.
            </p>

            다음으로 검증자의 **graffiti** 메시지에 대해 묻습니다:

            <img src={tuiExternalGraffiti} width="100%" height="auto"/>

            이것은 Beacon Chain에서 제안하는 모든 블록에 첨부할 수 있는 선택적 사용자 정의 메시지입니다.
            메시지는 영원히 보존되므로 흔적을 남기는 재미있는 작은 방법이라고 생각하세요!

            **graffiti의 최대 길이는 16자입니다.**

            오늘날 검증자가 Graffiti에 무엇을 사용하는지 몇 가지 예를 보려면 [여기를 살펴보세요](https://beaconcha.in/blocks).
          </Tab>

        </Tabs>
      </div>
    </Tab>

  </Tabs>
</div>

#### Beacon Chain Checkpoint Syncing

**Checkpoint syncing**은 일부 Beacon Chain 클라이언트가 지원하는 매우 유용한 기술입니다.
이를 통해 Beacon 클라이언트가 처음부터 시작하여 모든 블록을 따라잡을 필요 없이 전체 Beacon 체인을 즉시 동기화할 수 있습니다.
즉, **며칠**이 걸리는 대신 Beacon 클라이언트가 **몇 분** 만에 준비될 수 있습니다.
필요한 것은 신뢰할 수 있는 기존 Beacon 클라이언트에 대한 액세스뿐입니다.

HTTP API에 대한 액세스를 제공하는 모든 Beacon 노드를 사용할 수 있습니다.
현재 많은 노드 운영자가 checkpoint-sync-endpoints를 사용하고 있습니다. 이는 Rocket Pool 노드 운영자가 체크포인트 동기화를 쉽게 할 수 있도록 하는 서비스입니다.
Hoodi Testnet과 Mainnet이 모두 지원됩니다.
체크포인트 동기화 URL 목록은 다음 링크를 통해 찾을 수 있습니다:

- [Checkpoint Sync Urls](https://eth-clients.github.io/checkpoint-sync-endpoints/)

관련 체크포인트 동기화 URL을 선택하고 `rocketpool service config` 중에 Checkpoint Sync Provider를 묻는 메시지가 표시되면 터미널에 붙여넣으세요.

그 후 Beacon 노드는 처음 시작할 때 체크포인트 동기화 노드에 자동으로 연결하고 체인의 최신 상태를 즉시 가져옵니다!

::: warning 참고
Checkpoint Sync는 *Beacon Chain 데이터가 아직 없는 경우*에만 발생합니다.
즉, 정상적으로 동기화를 시작하고 나중에 체크포인트 동기화를 결정한 경우 체크포인트 동기화가 작동하려면 먼저 체인 데이터를 제거해야 합니다.
다음 명령으로 쉽게 수행할 수 있습니다:

```shell
rocketpool service resync-eth2
```

:::

### 폴백 노드

Smartnode 스택 1.5.0부터 기본 클라이언트가 오프라인 상태가 되면(예: Geth를 사용하고 프루닝해야 하는 경우) 대신 사용할 수 있는 "폴백" Execution 클라이언트와 Consensus 클라이언트 쌍을 제공할 수 있습니다.
이 상황에서 기본 노드 머신은 여전히 minipool의 검증자 키로 증명 및 블록 제안을 담당하지만 외부 머신에 연결하여 Execution layer 및 Beacon 체인과 상호 작용합니다.

[폴백 노드에 대해 자세히 알아보려면 이 섹션을 참조하고](./fallback) 완료되면 여기로 돌아오세요.

### 메트릭 구성

Rocket Pool에는 노드의 하드웨어 상태, 시스템 업데이트, 검증자 성능, 보상, 전체 Rocket Pool 네트워크에 대한 정보 등을 보여주는 자세한 대시보드를 표시하는 기능이 있습니다:

<img src="./images/nimbus-dashboard.png" width="100%" height="auto" />

마법사의 다음 질문은 이것을 활성화할지 묻습니다:

<img src="./images/tui-metrics.png" width="100%" height="auto" />

활성화하기로 선택한 경우 프로세스의 뒷부분에서 [Grafana 대시보드 설정하기](./grafana) 섹션에서 설정 방법과 사용 방법에 대해 자세히 알아볼 수 있습니다.

::: warning 참고
이 시스템에서 수집하는 모든 데이터는 **머신에 남아 있습니다**.
Rocket Pool은 원격 측정을 수집하거나 별도의 서비스로 보내지 않습니다.
순전히 자신의 노드를 모니터링할 수 있도록 사용할 수 있습니다!
:::

### MEV 구성

2022년 9월 Execution 및 Consensus 레이어 병합 이후 Ethereum 검증자는 이제 우선 수수료를 받고 MEV(Maximal Extractable Value)에 참여할 수 있습니다.

Smartnode v1.7.0부터 MEV는 이제 *opt-out*이므로 다음 화면에서 볼 수 있듯이 초기 설정의 일부로 구성이 제공됩니다:

<img src="./images/tui-mev-mode.png" width="100%" height="auto" />

[MEV, 구성 및 마법사의 이 섹션에서 수행할 작업에 대해 자세히 알아보려면 MEV 가이드를 읽어보세요.](./mev)
완료되면 여기로 돌아오세요.

### 완료

이 질문 후에 Smartnode 설정이 완료되었습니다!
다음 대화 상자가 표시됩니다:

<img src="./images/tui-finished.png" width="100%" height="auto" />

설정이 만족스럽고 Smartnode를 시작할 준비가 되었다면 여기에서 `Save and Exit`를 클릭하고 다음으로 [노드 보안](./securing-your-node) 섹션으로 이동하세요.

모든 설정을 검토하고 마법사에 포함되지 않은 많은 추가 설정을 사용자 정의하려면 `Review All Settings`를 클릭하고 [다음 섹션](#설정-관리자를-통한-구성)으로 이동하세요.

## 설정 관리자를 통한 구성

이미 `rocketpool service config`를 실행한 경우 마법사 대신 **설정 관리자** 화면이 표시됩니다:

<img src="./images/tui-settings-manager.png" width="100%" height="auto" />

이 화면에는 세 가지 주요 기능이 있습니다:

1. **Category List** - Smartnode 스택의 각 카테고리에 대한 설정을 드릴다운할 수 있습니다
2. **Review Changes and Save** 버튼 - 변경한 설정을 검토하고 업데이트된 구성을 저장할 준비가 되었을 때 사용할 수 있습니다
3. **Open the Config Wizard** 버튼 - 해당 인터페이스를 선호하는 경우 [설정 마법사](#마법사를-통한-구성)로 이동합니다

::: tip 팁
설정 관리자를 사용하려면 **`방향키`(위/아래/왼쪽/오른쪽)를 눌러 홈 페이지의 옵션 사이를 이동**하세요.

`Tab`을 눌러 화면 하단의 **카테고리 목록(1)과 버튼(2 및 3) 사이를 이동**하세요.
현재 선택된 버튼은 **녹색으로 강조 표시**됩니다.

**`Enter` 또는 `Space`를 눌러 버튼을 선택**하세요. 마우스로 클릭하는 것과 유사합니다.

**언제든지 `Ctrl`을 누른 상태에서 `C`를 눌러 아무것도 저장하지 않고 설정 관리자를 종료**할 수 있습니다.
:::

카테고리 목록을 스크롤하면 각 옵션에 대한 유용한 설명이 화면 오른쪽의 **Description Box**에 표시됩니다.
자유롭게 탐색하세요. **Review Changes and Save** 버튼을 통해 Review 대화 상자를 거치기 전까지는 아무것도 저장되지 않으며, 언제든지 **Ctrl+C**를 눌러 저장하지 않고 종료할 수 있으므로 여기서 설정을 가지고 놀면서 실수로 무언가를 망칠 일은 없습니다.

### 설정 구성

홈 화면에서 `Enter` 키로 카테고리 중 하나를 선택하여 해당 카테고리의 설정을 확인하세요.
예를 들어 **Smartnode and TX Fees** 카테고리의 화면은 다음과 같습니다:

<img src="./images/tui-smartnode.png" width="100%" height="auto" />

`방향키`를 사용하여 설정 사이를 위아래로 이동하세요.
현재 선택된 설정은 끝에 흰색 사각형이 있거나(텍스트 상자 또는 확인란인 경우) 흰색으로 강조 표시됩니다(드롭다운인 경우).

완료되면 `Escape`를 눌러 설정 관리자의 홈 화면으로 돌아가세요.

설정을 스크롤하면 각 설정이 수행하는 작업에 대한 간단한 설명이 오른쪽의 **Description Box**에 표시됩니다.
또한 스톡 설정으로 되돌리고 싶은 경우를 위해 **기본값**도 표시됩니다.

이 예에서는 **RPL Claim Gas Threshold** 설정이 현재 선택되어 있습니다(화면 왼쪽에 녹색 상자로 강조 표시됨).
`40`으로 변경되었지만 오른쪽 상단 모서리(**Description Box**의 상단)에서 기본값이 `150`임을 확인할 수 있습니다.

::: tip 팁
다시 말하지만, **Review Changes and Save** 버튼을 통해 Review 대화 상자를 거치기 전까지는 아무것도 디스크에 저장되지 않습니다.
모든 설정을 탐색하여 Smartnode가 무엇을 할 수 있는지 배우는 것이 좋습니다!
:::

### 설정 유형 및 사용 방법

설정 관리자는 다음 설정 유형 및 UI 요소를 사용합니다:

#### 텍스트 상자

텍스트 상자는 임의의 텍스트 또는 숫자 문자열을 입력하는 데 사용됩니다.
다음과 같이 보입니다:

<img src="./images/tui-textbox.png" width="100%" height="auto" />

원하는 값을 입력한 다음 **`Enter`를 누르거나 `방향키`를 사용하여 다른 설정으로 이동하여 변경 사항을 저장**하세요.
그렇지 않으면 설정 관리자는 여전히 해당 설정을 업데이트하고 있다고 가정하고 아직 변경된 것으로 표시하지 않습니다.

#### 드롭다운

드롭다운은 선택 목록에서 옵션을 선택하는 데 사용됩니다.
다음과 같이 보입니다(열려 있을 때):

<img src="./images/tui-dropdown-open.png" width="100%" height="auto" />

**녹색** 항목이 현재 선택된 항목입니다.
`방향키`를 사용하여 옵션을 변경하세요. 변경하면 오른쪽의 **Description Box**가 업데이트되어 현재 선택된 옵션에 대해 자세히 알려줍니다.
선택이 만족스러우면 `Enter`를 눌러 선택한 옵션을 선택하면 드롭다운이 닫히고 현재 선택된 옵션이 표시됩니다:

<img src="./images/tui-dropdown-closed.png" width="100%" height="auto" />

#### 확인란

확인란은 간단한 예/아니오 질문에 사용됩니다.
다음과 같이 보입니다:

<img src="./images/tui-checkbox-checked.png" width="100%" height="auto" />

확인란이 선택되면 위에서 볼 수 있듯이 중앙에 `X`가 표시됩니다.
확인란이 *선택 해제*되면 다음과 같이 단순히 비어 있습니다:

<img src="./images/tui-checkbox-unchecked.png" width="100%" height="auto" />

설정을 변경하려면 단순히 선택하고 `Enter`를 누르세요.

### 변경 사항 저장

변경 사항이 만족스럽고 저장하기 전에 검토하려면 홈 화면에서 **Review Changes and Save** 버튼을 누르세요.
다시 말하지만, 이동하려면 `Tab` 키를 누르세요.

다음과 같은 보기가 표시됩니다:

<img src="./images/tui-review.png" width="100%" height="auto" />

여기의 **Review Box**에는 변경한 모든 설정이 표시되며 이전 값과 새 값이 표시됩니다.
예를 들어 여기의 첫 번째 줄은 **RPL Claim Gas Threshold**가 `150`이었고 `40`으로 변경되었음을 보여줍니다.

또한 수정한 설정의 영향을 받는 컨테이너를 보여주고 변경 사항을 저장한 후 다시 시작할 수 있도록 제안합니다.

::: tip 참고
이 시점에서 변경 사항은 **아직 저장되지 않았습니다**.
무언가를 수정하고 싶다면 `Escape`를 눌러 홈 화면으로 돌아가세요.
:::

변경 사항이 만족스러우면 `Enter`를 눌러 새 구성을 디스크에 저장하세요.
그런 다음 터미널 UI를 종료하고 다음과 같은 메시지가 표시됩니다:

```
Your changes have been saved!
The following containers must be restarted for the changes to take effect:
	rocketpool_watchtower
	rocketpool_validator
	rocketpool_eth2
	rocketpool_node
Would you like to restart them automatically now? [y/n]
```

새 구성 변경 사항을 자동으로 적용하고 영향을 받는 컨테이너를 다시 시작하려면 `y`와 `Enter`를 누르세요.

다시 시작하기 전에 수행하려는 다른 작업이 있고 나중에 수동으로 수행할 경우 `n`과 `Enter`를 누르세요.

어느 경우든 구성이 완료되었습니다!

::: tip 참고
다음과 같은 오류 메시지가 표시될 수 있습니다:

```
2022/08/13 13:49:41 Error piping stdout: read |0: file already closed
```

이것은 실제로 오류가 아니라 단순히 외관상의 결함입니다.
안전하게 무시할 수 있습니다.
:::

::: tip 참고
Mac OS를 실행하는 경우 node_exporter에 대해 불평하는 문제가 표시될 수 있습니다.
수정하려면 다음 명령을 실행해야 합니다.

```shell
rocketpool service stop
nano ~/.rocketpool/override/exporter.yml
```

파일의 전체 내용을 다음으로 바꾸세요:

```
# Enter your own customizations for the node exporter container here. These changes will persist after upgrades, so you only need to do them once.
#
# See https://docs.docker.com/compose/extends/#adding-and-overriding-configuration
# for more information on overriding specific parameters of docker-compose files.

version: "3.7"
services:
  node-exporter:
    x-rp-comment: Add your customizations below this line
    volumes:   ["/proc:/host/proc:ro","/sys:/host/sys:ro"]
```

그런 다음 마지막으로 `rocketpool service start`.
:::

## 명령줄을 통한 구성

터미널 UI와 상호 작용할 수 없는 헤드리스 환경에서 Smartnode를 사용하는 경우 대신 명령줄을 통해 노드를 구성할 수 있습니다.

`rocketpool service config` 명령은 터미널 UI를 통해 일반적으로 구성할 수 있는 모든 설정을 인수로 허용합니다.
다음 명령을 실행하여 목록을 확인하세요(상당히 깁니다):

```shell
rocketpool service config --help
```

출력은 다음과 같습니다:

```
NAME:
   rocketpool service config - Configure the Rocket Pool service

USAGE:
   rocketpool service config

OPTIONS:
   --executionClientMode value  Choose which mode to use for your Execution client - locally managed (Docker Mode), or externally managed (Hybrid Mode).
                                Type: choice
                                Options: local, external
 (default: "local")
   --executionClient value  Select which Execution client you would like to run.
                            Type: choice
                            Options: geth, infura, pocket
 (default: "geth")
   --useFallbackExecutionClient         Enable this if you would like to specify a fallback Execution client, which will temporarily be used by the Smartnode and your Consensus client if your primary Execution client ever goes offline.
                                        Type: bool

...
```

각 옵션에는 이름, 유형, 기본값 및(선택 매개변수인 경우) 옵션이 있습니다.
이 텍스트를 사용하여 설정하려는 옵션을 찾고 적절한 인수를 통해 지정할 수 있습니다.

::: tip 참고
이 명령은 기존 구성 위에 구축되므로 이미 저장된 일부 설정이 있고 다른 설정만 수정하려는 경우 반복할 필요가 없습니다.
이 명령에 인수로 포함한 설정만 업데이트됩니다.
:::

## 다음 단계

원하는 대로 노드를 구성했으면 운영 체제를 보호하여 노드를 보호할 준비가 된 것입니다.
다음으로 [노드 보안](./securing-your-node) 섹션으로 이동하세요.
