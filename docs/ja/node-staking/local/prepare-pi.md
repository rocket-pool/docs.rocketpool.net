# Raspberry Piの準備

::: warning 注意
このページはアーカイブ目的で残されています。Ethereumバリデーターを実行するためのハードウェアとパフォーマンスの要件が増加したため、Raspberry PiでRocket Poolを実行することは推奨しなくなりました。
:::

このガイドでは、Raspberry Piを使用してRocket Poolノードを実行する方法について説明します。
これは通常、ほとんどのステーキングガイドでは推奨されていませんが、PC全体を立ち上げるよりもはるかに手頃なオプションであるため、魅力的であることは認識しています。
そのため、多数の設定を調整および最適化するために懸命に取り組み、うまく機能する構成を決定しました。

このセットアップでは、Pi上で**完全なExecutionノード**と**完全なConsensusノード**を実行し、Ethereumネットワークの健全性に貢献すると同時にRocket Poolノードオペレーターとして機能します。

## 事前セットアップ

Raspberry PiでRocket Poolノードを実行するには、まず動作するRaspberry Piが必要です。
すでに稼働している場合は、[SSDのマウント](#ssdのマウント)セクションまでスキップできます。
ただし、進む前に**ファンが取り付けられている**ことを確認してください。
ゼロから始める場合は、読み続けてください。

### 必要なもの

Raspberry PiでRocket Poolを実行するために購入する必要がある推奨コンポーネントは次のとおりです。

- **Raspberry Pi 4 Model B**、**8 GBモデル**
  - 注：このセットアップで4 GBを使用することも*できます*が、安心のために8 GBを使用することを強くお勧めします...それほど高価ではありません。
- Pi用の**USB-C電源**。**少なくとも3アンペア**を供給するものが必要です。
- **MicroSDカード**。大容量である必要はなく、16 GBで十分で、今はかなり安価です...しかし、少なくとも**クラス10（U1）**である必要があります。
- PC用の**MicroSD to USB**アダプター。これは、カードをPiにロードする前にオペレーティングシステムをカードにインストールするために必要です。
  PCにすでにSDポートがある場合は、新しいものを購入する必要はありません。
- いくつかの**ヒートシンク**。Piを24時間365日重負荷で実行することになり、熱くなります。
  ヒートシンクは、スロットリングを防ぐのに役立ちます。理想的には3つのセットが必要です。CPU用に1つ、RAM用に1つ、USBコントローラー用に1つです。
  [こちらは優れたセットの良い例です](https://www.canakit.com/raspberry-pi-4-heat-sinks.html)。
- **ケース**。ここには2つの方法があります。ファン付きとファンレスです。
  - ファン付き：
    - 40mmの**ファン**。上記と同じように、Rocket Poolノードを実行している間、物事を冷やしておくことが目標です。
    - すべてをまとめるための**ファンマウント付きケース**。
      [このような](https://www.amazon.com/Raspberry-Armor-Metal-Aluminium-Heatsink/dp/B07VWM4J4L)統合ファン付きケースを入手することもできるので、ファンを別々に購入する必要はありません。
  - ファンなし：
    - [このような](https://www.amazon.com/Akasa-RA08-M1B-Raspberry-case-Aluminium/dp/B081VYVNTX)1つの巨大なヒートシンクとして機能する**ファンレスケース**。
      これは静かなので良いオプションですが、Piは**非常に**熱くなります - 特に初期のブロックチェーン同期プロセス中はそうです。
      DiscordユーザーのKenに感謝します！
  - 一般的なルールとして、Piを大幅にオーバークロックするため、**ファン付き**をお勧めします。

便利なように、これらの多くをバンドルで入手できます。たとえば、[Canakitはキットを提供しています](https://www.amazon.com/CanaKit-Raspberry-8GB-Starter-Kit/dp/B08956GVXN)多くのコンポーネントが含まれています。
ただし、部品を個別に入手すると、すべてを安く入手できる可能性があります（また、機器があれば、[独自のPiケースを3Dプリント](https://www.thingiverse.com/thing:3793664)できます。）

必要なその他のコンポーネント：

- **USB 3.0+ソリッドステートドライブ**。一般的な推奨事項は**2 TBドライブ**です。
  - [Samsung T5](https://www.amazon.com/Samsung-T5-Portable-SSD-MU-PA2T0B/dp/B073H4GPLQ)は、うまく機能することが知られている優れた例です。
  - :warning: SATA-to-USBアダプターを使用したSATA SSDの使用は、[このような問題](https://www.raspberrypi.org/forums/viewtopic.php?f=28&t=245931)があるため**推奨されません**。
    この方法を選択する場合は、[SSDのパフォーマンステスト](#ssdのパフォーマンステスト)セクションで、機能するかどうかを確認するために使用できるパフォーマンステストを含めています。
- インターネットアクセス用の**イーサネットケーブル**。少なくとも**Cat 5e**定格である必要があります。
  - Wi-Fi経由でノードを実行することは**推奨されません**が、他のオプションがない場合は、イーサネットケーブルの代わりに使用できます。
- 停電時の電源として機能する**UPS**。
  Piは実際にはそれほど電力を消費しないため、小さなUPSでもしばらく持ちますが、一般的には大きいほど良いです。できるだけ大きなUPSを使用してください。
  また、**モデム、ルーター、その他のネットワーク機器**も接続することをお勧めします - ルーターが死んでしまうと、Piを生かしておいても意味がありません。

場所、セール、SSDとUPSの選択、およびすでに持っているものの数によっては、完全なセットアップに**約200ドルから500ドル（USD）**を費やすことになるでしょう。

### ファンをより静かに動作させる

ファンを入手すると、デフォルトでは、以下の写真に示すように、5v GPIOピンに接続するように指示される可能性があります。
ファンには2つの穴があるコネクタがあります。黒はGND（ピン6）に、赤は+5v（ピン4）に接続する必要があります。
![](./images/pi/Pinout.png)

ただし、私たちの経験では、これによりファンが非常に大きく速く動作し、実際には必要ありません。
より静かに、それでも冷たく動作させたい場合は、5vピンの代わりに3.3vピン（ピン1、青いもの）に接続してみてください。
これは、ファンの黒いポイントがGND（ピン6）に接続されたままになりますが、赤いポイントが+3.3v（ピン1）に接続されることを意味します。

ファンに2つの穴が並んでいて分割できないコネクタがある場合は、[このようなジャンパー](https://www.amazon.com/GenBasic-Female-Solderless-Breadboard-Prototyping/dp/B077N7J6C4)をPiのGPIOピンとの間に配置できます。

### オペレーティングシステムのインストール

Raspberry PiをサポートするさまざまなバージョンのLinux OSがあります。
このガイドでは、**Ubuntu 20.04**に固執します。
Ubuntuは世界中で使用されている実証済みのOSであり、20.04は（この記事の執筆時点で）Long Term Support（LTS）バージョンの最新版であり、非常に長い間セキュリティパッチを受け取り続けることを意味します。
Raspbianなどの別のフレーバーのLinuxを使用したい場合は、それに関する既存のインストールガイドに従ってください。ただし、このガイドはUbuntu用に作成されているため、すべての手順がOSと一致しない場合があります。

Canonicalの優れた方々は、[PiにUbuntu Serverイメージをインストールする方法に関する素晴らしいガイド](https://ubuntu.com/tutorials/how-to-install-ubuntu-on-your-raspberry-pi#1-overview)を書いています。

サーバーセットアップについては、上記のガイドの**ステップ1から4**に従ってください。
オペレーティングシステムイメージの場合は、`Ubuntu Server 20.04.2 LTS (RPi 3/4/400) 64-bit server OS with long-term support for arm64 architectures`を選択してください。

デスクトップUI（マウスを使用してドラッグできるウィンドウを持つことができるように）が必要な場合は、ステップ5にも従う必要があります。
デスクトップUIは追加のオーバーヘッドと処理作業をPiに追加し、比較的少ない利益しかないため、これを行わずにサーバーイメージに固執することをお勧めします。
ただし、デスクトップを実行することを決意している場合は、Xubuntuオプションを選択することをお勧めします。
リソースが非常に軽量で、非常にユーザーフレンドリーです。

これが完了したら、Rocket Poolノードを実行するためにUbuntuを準備する準備が整いました。
ローカルターミナルを使用することも、インストールガイドが示すようにデスクトップ/ラップトップからSSH接続することもできます。
どちらの方法でもプロセスは同じなので、最も便利な方法を選択してください。

`ssh`に慣れていない場合は、[Secure Shellの紹介](../ssh)ガイドをご覧ください。

::: warning 注意
この時点で、PiのIPアドレスを**静的**にするようにルーターを構成することを*強くお勧めします*。
これは、PiのIPアドレスが永続的になるため、そのIPアドレスを使用していつでもSSH接続できることを意味します。
そうしないと、PiのIPが変更される可能性があり、上記のSSHコマンドが機能しなくなる可能性があります。
ルーターの構成に入り、Piの新しいIPアドレスを見つける必要があります。

各ルーターは異なるため、静的IPアドレスを割り当てる方法については、ルーターのドキュメントを参照する必要があります。
:::

## SSDのマウント

上記のインストール手順に従った後、コアOSがmicroSDカードから実行されていることがわかります。
これは、すべてのExecutionとConsensusブロックチェーンデータを保持するには十分な大きさや速さではありません。そこでSSDが登場します。
使用するには、ファイルシステムでセットアップしてPiにマウントする必要があります。

### USB 3.0ポートへのSSDの接続

まず、SSDをPiのUSB 3.0ポートの1つに接続します。これらは黒いポートではなく**青い**ポートです。

![](./images/pi/USB.png)

黒いものは遅いUSB 2.0ポートです。マウスやキーボードなどのアクセサリにのみ適しています。
キーボードが青いポートに接続されている場合は、取り外して黒いポートに接続してください。

### SSDのフォーマットと新しいパーティションの作成

::: warning
このプロセスでは、SSD上のすべてが消去されます。
すでに物が入っているパーティションがある場合は、このステップをスキップしてください。すべてを削除しようとしているためです。
このSSDを使用したことがなく、完全に空の場合は、このステップに従ってください。
:::

次のコマンドを実行して、デバイステーブル内のディスクの場所を見つけます。

```shell
sudo lshw -C disk
  *-disk
       description: SCSI Disk
       product: Portable SSD T5
       vendor: Samsung
       physical id: 0.0.0
       bus info: scsi@0:0.0.0
       logical name: /dev/sda
       ...
```

重要なのは`logical name: /dev/sda`部分、つまり**`/dev/sda`**部分です。
これをSSDの**デバイスロケーション**と呼びます。
このガイドでは、デバイスロケーションとして`/dev/sda`を使用します - あなたのものはおそらく同じですが、残りの手順ではコマンドが表示するものに置き換えてください。

デバイスロケーションがわかったので、フォーマットして新しいパーティションを作成して、実際に使用できるようにしましょう。
繰り返しますが、**これらのコマンドは、ディスク上にすでにあるものをすべて削除します。**

新しいパーティションテーブルを作成します。

```shell
sudo parted -s /dev/sda mklabel gpt unit GB mkpart primary ext4 0 100%
```

新しいパーティションを`ext4`ファイルシステムでフォーマットします。

```shell
sudo mkfs -t ext4 /dev/sda1
```

ラベルを追加します（これを行う必要はありませんが、楽しいです）。

```shell
sudo e2label /dev/sda1 "Rocket Drive"
```

以下のコマンドを実行して、これが機能したことを確認してください。ここに表示されるような出力が表示されるはずです。

```shell
sudo blkid
...
/dev/sda1: LABEL="Rocket Drive" UUID="1ade40fd-1ea4-4c6e-99ea-ebb804d86266" TYPE="ext4" PARTLABEL="primary" PARTUUID="288bf76b-792c-4e6a-a049-cb6a4d23abc0"
```

これがすべて表示されれば、準備完了です。`UUID="..."`の出力を取得して、一時的にどこかに保存してください。すぐに必要になります。

### 新しいパーティションの最適化

次に、新しいファイルシステムを少し調整して、バリデーターアクティビティ用に最適化しましょう。

デフォルトでは、ext4はスペースの5％をシステムプロセス用に予約します。
SSDではExecutionとConsensusチェーンデータのみを保存するため、これは必要ありません。無効にできます。

```shell
sudo tune2fs -m 0 /dev/sda1
```

### マウントと自動マウントの有効化

ドライブを使用するには、ファイルシステムにマウントする必要があります。
好きな場所に新しいマウントポイントを作成します（ここでは例として`/mnt/rpdata`を使用しますが、自由に使用してください）。

```shell
sudo mkdir /mnt/rpdata
```

次に、新しいSSDパーティションをそのフォルダーにマウントします。

```shell
sudo mount /dev/sda1 /mnt/rpdata
```

この後、フォルダー`/mnt/rpdata`はSSDを指すため、そのフォルダーに書き込むものはすべてSSDに保存されます。
これは、ExecutionとConsensusのチェーンデータを保存する場所です。

次に、起動時に自動的にマウントされるように、マウントテーブルに追加しましょう。
以前に使用した`blkid`コマンドの`UUID`を覚えていますか？
ここで役立ちます。

```shell
sudo nano /etc/fstab
```

これにより、インタラクティブなファイルエディターが開きます。最初は次のようになります。

```
LABEL=writable  /        ext4   defaults        0 0
LABEL=system-boot       /boot/firmware  vfat    defaults        0       1
```

矢印キーを使用して一番下の行に移動し、この行を最後に追加します。

```
LABEL=writable  /        ext4   defaults        0 0
LABEL=system-boot       /boot/firmware  vfat    defaults        0       1
UUID=1ade40fd-1ea4-4c6e-99ea-ebb804d86266       /mnt/rpdata     ext4    defaults        0       0
```

`UUID=...`の値をディスクの値に置き換えてから、`Ctrl+O`と`Enter`を押して保存し、次に`Ctrl+X`と`Enter`を押して終了します。
これで、再起動時にSSDが自動的にマウントされます。素晴らしい！

### SSDのパフォーマンステスト

先に進む前に、SSDの読み取り/書き込み速度と、1秒あたりに処理できるI/Oリクエストの数（IOPS）をテストする必要があります。
SSDが遅すぎる場合、Rocket Poolノードではうまく機能せず、時間の経過とともにお金を失うことになります。

テストするには、`fio`というプログラムを使用します。次のようにインストールします。

```shell
sudo apt install fio
```

次に、SSDのマウントポイントに移動します。

```shell
cd /mnt/rpdata
```

次に、このコマンドを実行してSSDのパフォーマンスをテストします。

```shell
sudo fio --randrepeat=1 --ioengine=libaio --direct=1 --gtod_reduce=1 --name=test --filename=test --bs=4k --iodepth=64 --size=4G --readwrite=randrw --rwmixread=75
```

出力は次のようになります。

```
test: (g=0): rw=randrw, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=libaio, iodepth=64
fio-3.16
Starting 1 process
test: Laying out IO file (1 file / 4096MiB)
Jobs: 1 (f=1): [m(1)][100.0%][r=63.9MiB/s,w=20.8MiB/s][r=16.4k,w=5329 IOPS][eta 00m:00s]
test: (groupid=0, jobs=1): err= 0: pid=205075: Mon Feb 15 04:06:35 2021
  read: IOPS=15.7k, BW=61.5MiB/s (64.5MB/s)(3070MiB/49937msec)
   bw (  KiB/s): min=53288, max=66784, per=99.94%, avg=62912.34, stdev=2254.36, samples=99
   iops        : min=13322, max=16696, avg=15728.08, stdev=563.59, samples=99
  write: IOPS=5259, BW=20.5MiB/s (21.5MB/s)(1026MiB/49937msec); 0 zone resets
...
```

気にするのは、`test:`行の下の`read:`と`write:`で始まる行です。

- **read**は、少なくとも**15k**のIOPSと少なくとも**60 MiB/s**の帯域幅（BW）が必要です。
- **write**は、少なくとも**5000**のIOPSと少なくとも**20 MiB/s**の帯域幅が必要です。

これらは、私たちが使用しているSamsung T5の仕様であり、非常にうまく機能します。
また、読み取りIOPSが5k、書き込みIOPSが1kの低速SSDもテストしましたが、consensus layerに追いつくのに非常に苦労しています。
上記の仕様よりも遅いSSDを使用する場合は、多くの失敗したattestationが表示される可能性があることに注意してください。
あなたのものがそれらを満たすか超える場合は、すべて設定されており、先に進むことができます。

::: tip 注意
SSDが上記の仕様を満たしていないが、満たすはずの場合、ファームウェアアップデートで修正できる可能性があります。
たとえば、これはRocket PoolコミュニティでSamsung T7で経験されています。
箱から出したばかりの2つは、3.5Kの読み取りIOPSと1.2Kの書き込みIOPSしか表示されませんでした。
利用可能なすべてのファームウェアアップデートを適用した後、パフォーマンスは上記の例に示されている数値に戻りました。
最新のファームウェアについてはメーカーのサポートWebサイトを確認し、ドライブが最新であることを確認してください - 更新がなくなるまで、ファームウェアを複数回更新する必要がある場合があります。
:::

最後に、作成したテストファイルを削除します。

```shell
sudo rm /mnt/rpdata/test
```

## スワップスペースの設定

Piには8 GB（または4 GBを選択した場合は4 GB）のRAMがあります。
私たちの構成では、それで十分です。
そうは言っても、少し追加しても害はありません。
今から行うのは、**スワップスペース**と呼ばれるものを追加することです。
基本的に、何かがひどく間違ってPiが通常のRAMを使い果たした場合に備えて、SSDを「バックアップRAM」として使用することを意味します。
SSDは通常のRAMほど速くないため、スワップスペースに到達すると速度が低下しますが、完全にクラッシュしてすべてを壊すことはありません。
これは、（おそらく）決して必要としない追加の保険と考えてください。

### スワップファイルの作成

最初のステップは、スワップスペースとして機能する新しいファイルを作成することです。
使用する量を決定します - 合理的な開始点は8 GBなので、8 GBの通常のRAMと8 GBの「バックアップRAM」で合計16 GBになります。
超安全にするために、24 GBにすることもできます。そうすると、システムには8 GBの通常のRAMと24 GBの「バックアップRAM」で合計32 GBになりますが、これはおそらく過剰です。
幸いなことに、SSDには1または2 TBのスペースがあるため、スワップファイルに8から24 GBを割り当てることは無視できます。

このウォークスルーのために、良い中間点を選びましょう - たとえば、16 GBのスワップスペースで合計RAMは24 GBです。
進むにつれて、必要な数値を代入するだけです。

これを入力すると、`/mnt/rpdata/swapfile`という新しいファイルが作成され、16 GBのゼロで埋められます。
量を変更するには、`count=16`の数値を必要な値に変更するだけです。**これには長い時間がかかりますが、それで問題ありません。**

```shell
sudo dd if=/dev/zero of=/mnt/rpdata/swapfile bs=1G count=16 status=progress
```

次に、rootユーザーのみが読み書きできるように権限を設定します（セキュリティのため）。

```shell
sudo chmod 600 /mnt/rpdata/swapfile
```

次に、スワップファイルとしてマークします。

```shell
sudo mkswap /mnt/rpdata/swapfile
```

次に、有効にします。

```shell
sudo swapon /mnt/rpdata/swapfile
```

最後に、Piが再起動したときに自動的にロードされるように、マウントテーブルに追加します。

```shell
sudo nano /etc/fstab
```

最後に新しい行を追加して、ファイルが次のようになるようにします。

```
LABEL=writable  /        ext4   defaults        0 0
LABEL=system-boot       /boot/firmware  vfat    defaults        0       1
UUID=1ade40fd-1ea4-4c6e-99ea-ebb804d86266       /mnt/rpdata     ext4    defaults        0       0
/mnt/rpdata/swapfile                            none            swap    sw              0       0
```

`Ctrl+O`と`Enter`を押して保存し、次に`Ctrl+X`と`Enter`を押して終了します。

アクティブであることを確認するには、次のコマンドを実行します。

```shell
sudo apt install htop
htop
```

出力は、上部で次のようになります。
![](./images/pi/Swap.png)

`Swp`というラベルの付いた最後の行の2番目の数値（`/`の後のもの）がゼロ以外の場合、すべて設定されています。
たとえば、`0K / 16.0G`が表示されている場合、スワップスペースは正常にアクティブ化されました。
`0K / 0K`が表示されている場合、機能しませんでした。前の手順を正しく入力したことを確認する必要があります。

`q`または`F10`を押して、`htop`を終了してターミナルに戻ります。

### スワップ性とキャッシュ圧力の構成

デフォルトでは、LinuxはシステムのRAMの圧力を軽減するために、多くのスワップスペースを積極的に使用します。
それは望んでいません。スワップに頼る前に、最後の最後までRAMをすべて使用してほしいのです。
次のステップは、システムの「スワップ性」を変更することです。これは基本的に、スワップスペースを使用する熱心さです。
これをどの値に設定するかについては多くの議論がありますが、6の値がうまく機能することがわかりました。

また、「キャッシュ圧力」を下げたいと思います。これは、Piがファイルシステムのキャッシュを削除する速度を決定します。
セットアップには予備のRAMがたくさんあるので、これを「10」にすることができます。これにより、キャッシュがメモリに長時間残り、ディスクI/Oが削減されます。

これらを設定するには、次のコマンドを実行します。

```shell
sudo sysctl vm.swappiness=6
sudo sysctl vm.vfs_cache_pressure=10
```

次に、再起動後に再適用されるように、`sysctl.conf`ファイルに入れます。

```shell
sudo nano /etc/sysctl.conf
```

最後に次の2行を追加します。

```shell
vm.swappiness=6
vm.vfs_cache_pressure=10
```

次に、前と同じように保存して終了します（`Ctrl+O`、`Ctrl+X`）。

## Piのオーバークロック

デフォルトでは、Piに付属する1.5 GHzプロセッサーは、かなり有能な小さなデバイスです。
ほとんどの場合、問題なく検証できるはずです。
ただし、まれに、バリデータークライアントが何かの作業で行き詰まり、バリデーターのattestation dutiesに追いつくための十分な馬力がないことに気づきました。
それが起こると、[beaconcha.in explorer](https://beaconcha.in)で次のようなものが表示されます（後の[ノードのパフォーマンスの監視](../performance)ガイドで詳しく説明します）。

![](./images/pi/Incl-Dist.png)

そのinclusion distanceが8であるということは、そのattestationの送信に非常に長い時間がかかったことを意味し、遅れたことに対してわずかにペナルティが課されます。
理想的には、すべてが0である必要があります。
まれではありますが、これらはストック設定で実行している場合に発生します。

ただし、これを軽減する方法があります。オーバークロックです。
オーバークロックは、PiのCPUから追加のパフォーマンスを引き出し、厄介な高いinclusion distanceを防ぐための最も簡単な方法です。
率直に言って、デフォルトのCPUクロックである1.5 GHzは本当にパワー不足です。
オーバークロックによってかなり速くすることができます。どこまで行くかによっては、非常に安全に行うこともできます。

Piのオーバークロックは非常に簡単です - テキストファイルの数値を変更するだけです。
重要な数値は2つあります。1つ目は**コアクロック**で、ARM CPUの実行速度を直接決定します。
2つ目は**オーバーボルテージ**で、ARM CPUに供給される電圧を決定します。
高速化には通常、より高い電圧が必要ですが、PiのCPUはかなりの量の追加電圧を処理できます。顕著な損傷はありません。
少し早く摩耗する可能性がありますが、まだ数年単位で話しており、その時点でPi 5が出ているので、実際には害はありません。

むしろ、オーバーボルテージの本当の懸念は、**高電圧が高温につながる**ことです。
このセクションでは、Piが重負荷でどれだけ熱くなるかを確認して、やりすぎないようにするのに役立ちます。

::: warning
私たちが行うレベルでのオーバークロックはかなり安全で信頼性がありますが、「シリコンの宝くじ」に左右されます。
すべてのCPUは微視的な方法でわずかに異なり、他のCPUよりも単純にオーバークロックできるものがあります。
オーバークロックしすぎる/難しすぎる場合、システムが**不安定**になる可能性があります。
不安定なPiは、常に再起動から完全にフリーズまで、あらゆる種類の結果に悩まされます。
**最悪の場合、microSDカードが破損し、ゼロからすべてを再インストールする必要があります。**

**ここでのガイダンスに従うことにより、そのリスクを実行していることを受け入れる必要があります。**
それがあなたにとって価値がない場合は、このセクションの残りをスキップしてください。
:::

## ストック構成のベンチマーク

オーバークロックする前に、Piが在庫の状態で何ができるかをプロファイルする必要があります。
見るべき重要なことは3つあります。

1. **パフォーマンス**（Piが物事を計算する速度）
2. 負荷時の**温度**（どれだけ熱くなるか）
3. **安定性**（クラッシュする前にどれだけ長く実行されるか）

進むにつれて、これら3つすべての統計を取得します。

### パフォーマンス

パフォーマンスを測定するために、LINPACKを使用できます。
ソースからビルドします。

```shell
cd ~
sudo apt install gcc
wget http://www.netlib.org/benchmark/linpackc.new -O linpack.c
...
cc -O3 -o linpack linpack.c -lm
...
sudo mv linpack /usr/local/bin
rm linpack.c
```

次のように実行します。

```shell
linpack
Enter array size (q to quit) [200]:
```

`enter`を押してデフォルトの200のままにし、実行させます。
完了すると、出力は次のようになります。

```
Memory required:  315K.


LINPACK benchmark, Double precision.
Machine precision:  15 digits.
Array size 200 X 200.
Average rolled and unrolled performance:

    Reps Time(s) DGEFA   DGESL  OVERHEAD    KFLOPS
----------------------------------------------------
     512   0.70  85.64%   3.76%  10.60%  1120802.516
    1024   1.40  85.70%   3.74%  10.56%  1120134.749
    2048   2.81  85.71%   3.73%  10.56%  1120441.752
    4096   5.62  85.69%   3.74%  10.57%  1120114.452
    8192  11.23  85.67%   3.74%  10.59%  1120277.186
```

見る必要があるのは、`KFLOPS`列の最後の行です。
この数値（上記の例では1120277.186）は、コンピューティングパフォーマンスを表します。
それ自体では何も意味しませんが、オーバークロックされたパフォーマンスと比較するための良いベースラインを提供します。
これを**ストックKFLOPS**と呼びましょう。

### 温度

次に、Piにストレスをかけて、重負荷時の温度を監視しましょう。
まず、このパッケージをインストールします。これにより、Piの詳細を印刷できる`vcgencmd`というツールが提供されます。

```shell
sudo apt install libraspberrypi-bin
```

これがインストールされたら、Piを再起動します（いくつかの新しい権限を適用するために必要です）。
次に、**stressberry**というプログラムをインストールします。
これがベンチマークツールになります。
次のようにインストールします。

```shell
sudo apt install stress python3-pip
pip3 install stressberry
source ~/.profile
```

::: tip 注意
stressberryが温度情報を読み取れない、または`vchiq`インスタンスを開けないというエラーをスローする場合は、次のコマンドで修正できます。

```shell
sudo usermod -aG video $USER
```

次に、ログアウトして再度ログインするか、SSHセッションを再起動するか、マシンを再起動して再試行してください。
:::

次に、次のように実行します。

```shell
stressberry-run -n "Stock" -d 300 -i 60 -c 4 stock.out
```

これにより、Piのすべての4コアで60秒のクールダウンを使用して、300秒（5分）間「Stock」という名前の新しいストレステストが実行されます。
より長く実行したり、クールダウンを増やしたい場合は、これらのタイミングを調整できますが、これは私にとって素早く汚いストレステストとして機能します。
結果は`stock.out`というファイルに保存されます。

テストのメインフェーズ中、出力は次のようになります。

```
Current temperature: 41.3°C - Frequency: 1500MHz
Current temperature: 41.3°C - Frequency: 1500MHz
Current temperature: 41.8°C - Frequency: 1500MHz
Current temperature: 40.9°C - Frequency: 1500MHz
Current temperature: 41.8°C - Frequency: 1500MHz
```

これは基本的に、Piがどれだけ熱くなるかを示します。
85°Cで、Piは実際にスロットリングを開始し、クロック速度を下げて過熱しないようにします。
幸いなことに、ヒートシンクとファンを追加したため、これに近づくことはないはずです。
とはいえ、一般的にシステムの全体的な健康のために温度を65°C未満に保つようにしています。

通常の検証操作中にシステム温度を監視したい場合は、`vcgencmd`でこれを行うことができます。

```shell
vcgencmd measure_temp
temp=34.0'C
```

### 安定性

オーバークロックの安定性をテストするには、次の3つの質問に答える必要があります。

- Piはオンになり、ログインプロンプト/ SSHサーバーを起動しますか？
- 通常の操作中にランダムにフリーズまたは再起動しますか？
- 重負荷時にランダムにフリーズまたは再起動しますか？

オーバークロックが真に安定するためには、答えは**はい、いいえ、いいえ**でなければなりません。
これをテストする方法はいくつかありますが、この時点で最も簡単なのは、`stressberry`を非常に長時間実行することです。
どれくらいの長さは完全にあなた次第です - 長く続くほど、システムが安定していることをより確信できます。
一部の人々は、上記の5分間のテストを実行するだけで、生き残れば良いと言います。他の人は30分間実行します。他の人は8時間以上実行します。
実行する時間は、自分のリスク許容度に基づいて行う必要がある個人的な決定です。

ランタイムを変更するには、`-d`パラメーターをテストを実行する秒数で変更するだけです。
たとえば、30分が良い方法だと決めた場合は、`-d 1800`を実行できます。

## 最初のオーバークロック - 1800 MHz（軽量）

最初に行うオーバークロックは比較的「軽量」で信頼性がありますが、それでも計算能力の良いブーストを提供します。
ストックの1500 MHzから1800 MHzに移行します - 20％の高速化です。

このファイルを開きます。

```shell
sudo nano /boot/firmware/usercfg.txt
```

最後に次の2行を追加します。

```shell
arm_freq=1800
over_voltage=3
```

次に、ファイルを保存して再起動します。

これらの設定により、CPUクロックが20％増加し、CPU電圧も0.88vから0.93vに上昇します（各`over_voltage`設定により0.025v増加します）。
この設定は、どのPi 4Bでも達成可能である必要があるため、システムは再起動し、わずか数分でログインプロンプトまたはSSHアクセスを提供するはずです。
そうでない場合、Piが応答しなくなったり、ブートループに入ったりした場合は、リセットする必要があります - 次のセクションを読んでください。

### 不安定なオーバークロック後のリセット

Piが応答しなくなった場合、または何度も再起動し続ける場合は、オーバークロックを下げる必要があります。
そのためには、次の手順に従ってください。

1. Piをオフにします。
2. microSDカードを抜きます。
3. カードをmicroSDアダプターを使用して別のLinuxコンピューターに接続します。\*注：これ**は**別のLinuxコンピューターである必要があります。SDカードが使用する`ext4`ファイルシステムをWindowsが読み取れないため、Windowsマシンに接続しても機能しません。\*\*
4. 他のコンピューターにカードをマウントします。
5. `<SD mount point>/boot/firmware/usercfg.txt`を開きます。
6. `arm_freq`値を下げるか、`over_voltage`値を増やします。_注：**over_voltage = 6を超えないでください。**より高い値はPiの保証でサポートされておらず、快適に感じるよりも速くCPUを劣化させるリスクがあります。_
7. SDカードをアンマウントして取り外します。
8. カードをPiに戻して、オンにします。

Piが機能すれば、素晴らしい！以下に続けてください。
そうでない場合は、さらに保守的な設定でプロセス全体を繰り返します。
最悪の場合、`arm_freq`と`over_voltage`の行を完全に削除して、ストック設定に戻すことができます。

### 1800 MHzのテスト

ログインしたら、`linpack`を再度実行して新しいパフォーマンスをテストします。
テストPiの例は次のとおりです。

```
linpack
Enter array size (q to quit) [200]:
...
    Reps Time(s) DGEFA   DGESL  OVERHEAD    KFLOPS
----------------------------------------------------
     512   0.59  85.72%   3.75%  10.53%  1338253.832
    1024   1.18  85.72%   3.75%  10.53%  1337667.003
    2048   2.35  85.72%   3.75%  10.53%  1337682.272
    4096   4.70  85.73%   3.75%  10.53%  1337902.437
    8192   9.40  85.71%   3.76%  10.53%  1337302.722
   16384  18.80  85.72%   3.75%  10.52%  1337238.504
```

再び、最後の行の`KFLOPS`列を取得します。
ストック構成と比較するには、2つの数値を単純に割ります。
`1337238.504 / 1120277.186 = 1.193668`

いいですね！これは19.4％のパフォーマンスの向上であり、20％速く実行しているため、予想されることです。
次に、新しいクロック速度と電圧設定で温度を確認しましょう。

```shell
stressberry-run -n "1800_ov3" -d 300 -i 60 -c 4 1800_ov3.out
```

次のような出力が表示されるはずです。

```
Current temperature: 47.2°C - Frequency: 1800MHz
Current temperature: 48.7°C - Frequency: 1800MHz
Current temperature: 47.7°C - Frequency: 1800MHz
Current temperature: 47.7°C - Frequency: 1800MHz
Current temperature: 47.7°C - Frequency: 1800MHz
```

悪くありません、ストック設定よりも約6°熱いですが、個人的に止めるしきい値をはるかに下回っています。

快適な場合は、ここでより長い安定性テストを実行できます。または、さらに高くするために押し進めることができます。

## 2000 MHz（中）に移行

次のマイルストーンは2000 MHzです。これはクロック速度の33.3％のブーストを表し、かなり重要です。
ほとんどの人は、これがパフォーマンスと安定性の間の優れたバランスであると考えているため、ここでプロセスを停止します。

このレベルの推奨事項は、次の設定から始めることです。

```shell
arm_freq=2000
over_voltage=5
```

これにより、コア電圧が1.005vにブーストされます。
`linpack`と`stressberry`テストでこれを試してください。
それらが生き残れば、すべて設定されています。フリーズまたはランダムに再起動する場合は、電圧を上げる必要があります。

```shell
arm_freq=2000
over_voltage=6
```

これにより、コア電圧が1.03vになり、保証を無効にする前に行けるだけ高くなります。
それは通常、ほとんどのPiで機能します。
そうでない場合は、電圧をさらに上げる代わりに、**クロック速度を下げて再試行する必要があります。**

参考までに、2000実行の数値は次のとおりです。

```
linpack
Enter array size (q to quit) [200]:
...
    Reps Time(s) DGEFA   DGESL  OVERHEAD    KFLOPS
----------------------------------------------------
     512   0.53  85.76%   3.73%  10.51%  1482043.543
    1024   1.06  85.74%   3.73%  10.53%  1481743.724
    2048   2.12  85.74%   3.72%  10.54%  1482835.055
    4096   4.24  85.73%   3.74%  10.53%  1482189.202
    8192   8.48  85.74%   3.73%  10.53%  1482560.117
   16384  16.96  85.74%   3.73%  10.53%  1482441.146
```

これは32.3％の高速化で、予想される内容と一致しています。悪くないです！

温度は次のとおりです。

```
Current temperature: 54.0°C - Frequency: 2000MHz
Current temperature: 54.5°C - Frequency: 2000MHz
Current temperature: 54.0°C - Frequency: 2000MHz
Current temperature: 54.5°C - Frequency: 2000MHz
Current temperature: 55.5°C - Frequency: 2000MHz
```

さらに7度の増加ですが、まだ65°Cのしきい値を下回っています。

## 2100 MHz（重量）に移行

次のステップは、ストック構成よりも堅実な**40％の高速化**を表します。

**注：すべてのPiが`over_voltage = 6`を維持しながらこれを実行できるわけではありません。
試してみて、壊れた場合は2000 MHzに戻ってください。**

構成は次のようになります。

```shell
arm_freq=2100
over_voltage=6
```

参考までに、結果は次のとおりです。

```
linpack
Enter array size (q to quit) [200]:
...
    Reps Time(s) DGEFA   DGESL  OVERHEAD    KFLOPS
----------------------------------------------------
     512   0.50  85.68%   3.76%  10.56%  1560952.508
    1024   1.01  85.68%   3.76%  10.56%  1554858.509
    2048   2.01  85.70%   3.74%  10.56%  1561524.482
    4096   4.03  85.72%   3.73%  10.55%  1560152.447
    8192   8.06  85.72%   3.73%  10.54%  1561078.999
   16384  16.11  85.73%   3.73%  10.54%  1561448.736
```

それは39.4％の高速化です！

温度は次のとおりです。

```
Current temperature: 59.4°C - Frequency: 2100MHz
Current temperature: 58.9°C - Frequency: 2100MHz
Current temperature: 58.4°C - Frequency: 2100MHz
Current temperature: 59.4°C - Frequency: 2100MHz
Current temperature: 58.9°C - Frequency: 2100MHz
```

60°Cのすぐ下なので、十分な余裕があります。

## 2250 MHz（エクストリーム）に移行

これは、執筆時点で1年以上安定しているPiで実行する設定です。
それでも、**ユーザーはこれほど高くオーバークロックすることに注意する必要があります** - これをノードの本番構成にしようとする前に、徹底的な安定性テストと十分な熱的余裕があることを確認してください！

構成は次のとおりです。

```shell
arm_freq=2250
over_voltage=10
```

結果は次のとおりです。

```
    Reps Time(s) DGEFA   DGESL  OVERHEAD    KFLOPS
----------------------------------------------------
    1024   0.95  85.69%   3.85%  10.47%  1650081.294
    2048   1.91  85.64%   3.91%  10.45%  1646779.068
    4096   3.84  85.41%   4.15%  10.44%  1637706.598
    8192   7.75  85.50%   4.03%  10.46%  1620589.096
   16384  15.34  85.43%   4.13%  10.44%  1638067.854
```

それはストック構成より46％速いです！

OV10はストックファームウェアがPiを行ける限りであり、2250 MHzは本番環境で確実に実行できる最速でした。

ストレステストの温度はこれほど高くなります。

```
Current temperature: 70.6°C - Frequency: 2251MHz
Current temperature: 71.1°C - Frequency: 2251MHz
Current temperature: 71.1°C - Frequency: 2251MHz
Current temperature: 71.1°C - Frequency: 2251MHz
Current temperature: 71.1°C - Frequency: 2251MHz
```

しかし、実際の検証中は、60C未満にとどまる傾向があり、私たちにとって許容範囲です。

## 次のステップ

これで、Piが起動して実行され、Rocket Poolを実行する準備が整いました。
[ETHクライアントの選択](../eth-clients)セクションに進んでください。
