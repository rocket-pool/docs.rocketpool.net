import { Tab, Tabs } from "@rspress/core/theme";
import ECSelection from "./images/tui-ec-selection.png";
import tuiExternalEC from "./images/tui-external-ec.png";
import tuiLocalCC from "./images/tui-local-cc.png";
import tuiLocalGraffiti from "./images/tui-local-graffiti.png";
import tuiLocalCheckpoint from "./images/tui-local-checkpoint.png";
import tuiLocalDD from "./images/tui-local-dd.png";
import tuiExternalLH from "./images/tui-external-lh.png";
import tuiExternalGraffiti from "./images/tui-external-graffiti.png";
import tuiExternalDD from "./images/tui-external-dd.png";
import tuiExternalPrysm from "./images/tui-external-prysm.png";
import tuiExternalTeku from "./images/tui-external-teku.png";

# Smartnodeスタックの設定（Docker / Hybridモード）

完全なExecution層とConsensus層のクライアントを実行することは困難に思えるかもしれません。選択できるオプションがいくつかあり、それぞれに多数の異なる設定があります。
幸いなことに、Smartnodeはそのような複雑さをすべて隠すように設計されており、迅速かつ簡単に設定できる一方で、必要に応じてすべてをカスタマイズする自由も提供します。

このセクションでは、**Dockerベースのセットアップ**を使用している場合、または外部で管理されているExecutionまたはConsensusクライアント（例えば、ソロステーキング用にSmartnode外で管理しているクライアント）に接続する**Hybridセットアップ**を使用している場合の、Smartnodeを設定するさまざまな方法について説明します。

::: warning 注意
Dockerを使用しないNativeモードを使用している場合は、代わりに[Native設定ガイド](./config-native)をご覧ください。
:::

設定には3つの方法があります。

- [ウィザードUI](#ウィザードによる設定)経由 - これが最も簡単な方法です。いくつかの基本的な質問だけを行い、十分にテストされたデフォルト値を使用します。これは初めて`rocketpool service config`を実行したときに表示されます。
- [設定マネージャーUI](#設定マネージャーによる設定)経由 - これにより、Smartnodeのすべての設定にアクセスでき、必要なだけカスタマイズできます。
- [コマンドライン](#コマンドラインによる設定)によるヘッドレス設定 - これは、Smartnodeをヘッドレス（非対話型）環境で実行し、自動的に設定する必要がある人向けのオプションです。

上記のリストから詳しく知りたいモードを選択するか、以下の各オプションをスクロールしてください。

## ウィザードによる設定

設定プロセスを開始するには、次のコマンドを実行します。

```shell
rocketpool service config
```

これにより、ターミナルベースのUIが起動し、ノードを迅速かつ簡単に設定できるとともに、高度なカスタマイズのためのすべての設定に対するオプションの詳細な制御も提供されます。

::: tip 注意
すでにSmartnodeを設定している場合は、代わりに[設定マネージャー](#設定マネージャーによる設定)が表示されます。
そこからウィザードを再度開くこともでき、既存の設定がすべて事前選択されています。
:::

設定UIを初めて実行すると（または後でウィザードを再度実行することを選択した場合）、次のような画面が表示されます。

<img src="./images/tui-first-time.png" width="100%" height="auto" />

::: tip ヒント
ウィザードを使用するには、**`矢印キー`（上/下/左/右）を押して、ボタン（選択肢）やテキストボックスなどの間を移動します**。
`Tab`と`Shift+Tab`を使用することもできます - 同じことができます。

ボタンの場合、**現在選択されているものが緑色でハイライト表示されます**。
黒いものは選択されていません。
上のスクリーンショットでは、`Next`が現在選択されており、`Quit`は選択されていません。

**`Enter`または`Space`を押してボタンを選択します**。これはマウスでクリックするのと同じです。

**`Escape`を押すと前のダイアログに戻ります**。何かについて気が変わった場合に便利です。
これは、さまざまなウィザードページを進むにつれて役立ちます。

**いつでも`Ctrl`を押しながら`C`を押すと、何も保存せずにウィザードを終了できます**。

たとえば、上の画面では、`左`と`右`の矢印キーを押して`Next`と`Quit`ボタンの間を移動できます。

`Next`が選択されているときに`Enter`を押すと、次の画面に進みます。
`Quit`が選択されているときに`Enter`を押すと、保存せずにウィザードを終了します。
:::

準備ができたら、`Next`を押してください。

### ネットワークの選択

次の画面では、使用するネットワークを選択するよう求められます。

<img src="./images/tui-network.png" width="100%" height="auto" />

`上`と`下`の矢印キー（または`Tab`と`Shift+Tab`）を使用して、さまざまな選択肢をハイライト表示できます。
選択肢を変更すると、右側の**説明**ボックスに各オプションの簡単な説明が表示されます。
これはウィザードのすべての選択ベースのページに当てはまり、ネットワーク選択だけではありません。したがって、このスタイルのページは頻繁に表示されます。

無料で入手できる偽のETHとRPLを使ってHoodiテストネットワークでRocket Poolノードを実行する練習をしたい場合は、**Hoodi Testnet**を選択してください。

実際の報酬を得るために本物のRocket PoolノードをMainnetで作成する準備ができている場合は、**Mainnet**を選択してください。

### クライアントモード

クライアントモードには2つのオプションが表示されます。

<img src="./images/tui-client-mode.png" width="100%" height="auto" />

**Locally Managed**（**「Dockerモード」**とも呼ばれます）がデフォルトの選択肢です。
すでにクライアントペアを持っておらず、Smartnodeに管理してもらいたい場合に使用します。
これを選択すると、SmartnodeはDockerコンテナとしてExecution & Consensusクライアントペアを作成、設定、管理します。
心配しないでください、次に実行する*どの*クライアントを選択するかを決めることができます。

**Externally Managed**（**「Hybridモード」**とも呼ばれます）は、すでに別の場所で手動で管理しているExecution & Consensusクライアントペアを実行しているユーザーにとって便利な選択肢です。
これを選択すると、Smartnodeは既存のクライアントに接続するだけで、独自のクライアントは実行しません。
たとえば、ユーザーは現在ソロステーキングに使用しているクライアントにプラグインすることができます。そうすれば、クライアントの2つの別々のコピーを持つ必要がありません。

:::warning 注意
Execution-Consensus LayerのMerge以降、これらのモードを混在させることは*できません*（例えば、ローカルExecutionクライアントと外部管理Consensusクライアントを持つことはできません）。
すべてローカル管理またはすべて外部管理のいずれかを選択する必要があります。
:::

### Executionクライアントの設定

Executionクライアントを管理するために使用するモードを選択し、以下の対応するタブの手順に従ってください。

<div className="p-3">
  <Tabs>
    <Tab label="Locally Managed">
      SmartnodeにExecutionクライアントを管理してもらいたい場合、次の画面でクライアントを選択するよう求められます。

      <img src={ECSelection} width="100%" height="auto"/>

      各オプションの説明については、[ETHクライアントの選択](/ja/node-staking/eth-clients#execution-clients)セクションを参照してください。
      選択したら、以下の適切なタブをクリックして設定方法を学んでください。

      **Geth**、**Besu**、または**Nethermind**を選択した場合、ウィザードがすべての設定を処理します。
      このプロセスの最後にいくつかのパラメータを手動で調整できますが、使用されるデフォルト値はノード操作に完全に適しています。
      次のセクションに進むことができます。


      <p className="rspress-directive warning">
        <p className="rspress-directive-title">注意</p>
        **ルーターのポート転送設定でP2Pポートを開いてください**。**ポート30303**のTCPとUDPの両方をマシンのローカルIPアドレスに転送するように設定します。
        これにより、他のConsensusクライアントがそれを発見し、外部から通信できるようになります。これにより、Consensusクライアントが迅速に同期し、パフォーマンス（したがって報酬）が向上します。

        各ルーターには異なる方法があるため、**ポート転送の設定方法については、ルーターのマニュアルを確認する必要があります**。
      </p>

      <p className="rspress-directive warning">
        <p className="rspress-directive-title">注意</p>
        Smartnodeは独自のDockerコンテナで実行されるため、Dockerの内部ネットワークを使用します。
        ここでは`localhost`や`127.0.0.1`のようなホスト名を使用できません。Executionクライアントが Smartnodeと同じマシンで実行されている場合は、代わりにマシンのLAN IPアドレスを提供する必要があります。
      </p>

      これで、Executionクライアントの設定はすべて完了です。
    </Tab>
    <Tab label="External">
      外部管理のExecutionクライアントの場合、次の画面でHTTPベースのRPC（web3）APIのURLとWebsocketベースのRPC APIのURLを入力するよう求められます。

      <img src={tuiExternalEC} width="100%" height="auto"/>

      SmartNodeはHTTP URLを使用して通信し、チェーンの状態のクエリやトランザクションの送信などのブロックチェーンアクティビティを実行します。
      **まだクライアントのAPIポートを有効にしてSmartNodeマシンからアクセスできるようにしていない場合は、今すぐ設定する必要があります。**
      これに関する手順はクライアントごとに異なります。HTTP RPCエンドポイントの設定方法については、クライアントのドキュメントを参照してください。

      Websocket URLは、自分で使用する必要がある場合にのみ関連します。Smartnodeは使用しません。
      必要ない場合は空白のままにできます。

      <p className="rspress-directive warning">
        <p className="rspress-directive-title">注意</p>
        Smartnodeは独自のDockerコンテナで実行されるため、Dockerの内部ネットワークを使用します。
        ここでは`localhost`や`127.0.0.1`のようなホスト名を使用できません。フォールバックExecutionクライアントがSmartnodeと同じマシンで実行されている場合は、代わりにマシンのLAN IPアドレスを提供する必要があります。
      </p>

      フォールバックExecutionクライアントの選択に満足したら、次のステップに進みます。
    </Tab>

  </Tabs>
</div>

### Consensusクライアントの設定

Executionクライアントの準備ができたので、次のタスクはConsensusクライアントの設定です。
「モード」（ローカルまたは外部）は、以前にExecutionクライアントに使用した選択から継承されます。

以下のタブから以前に選択したモードを選択してください。

<div className="p-3">
  <Tabs>
    <Tab label="Locally Managed">
      SmartnodeにConsensusクライアントを管理してもらいたい場合、次の画面でクライアントを選択するよう求められます。

      <img src={tuiLocalCC} width="100%" height="auto"/>

      ネットワーク全体の健全性と多様性のために**推奨される選択肢**は、**Random (Recommended)**選択肢です。これは、サポートされている4つのConsensusクライアントの中からランダムに1つを選択します。

      明示的にクライアントを選択したい場合は、[ETHクライアントの選択](./eth-clients#eth2-clients)セクションを参照して、各オプションの説明を読んで、十分な情報に基づいた決定を下してください。


      <p className="rspress-directive warning">
        <p className="rspress-directive-title">注意</p>
        クライアント選択に基づいて警告が表示される2つの条件があります。

        - 選択したクライアントが現在[スーパーマジョリティクライアント](https://clientdiversity.org/)である場合、つまり、Beacon Chainのバリデータの不健全な大多数がそれを使用しており、ネットワークの安定性を脅かしている

        - 選択したクライアントが現在使用しているハードウェアに対して**リソースを消費しすぎる**場合

        選択したクライアントにこれらのケースのいずれかが当てはまる場合、警告が表示され、別のクライアントを選択するよう求められます。
        選択したものを引き続き使用するオプションもありますが、そうすることのリスクを認識しておく必要があります。
      </p>

      選択を行ったか、ランダムクライアントが割り当てられたら、以下の適切なタブをクリックして設定方法を学んでください。

      <div className="p-3">
        <Tabs>
          <Tab label="Lighthouse">
            Lighthouseの設定の最初のオプションは、バリデータの**graffiti**メッセージについて尋ねます。

            <img src={tuiLocalGraffiti} width="100%" height="auto"/>

            これは、Beacon Chainで提案するブロックに添付できるオプションのカスタムメッセージです。
            メッセージは永遠に保存されるので、自分の痕跡を残す楽しい小さな方法と考えてください。

            **graffitiの最大長は16文字です。**

            今日バリデータがGraffitiに何を使用しているかの例を見たい場合は、[こちらをご覧ください](https://beaconcha.in/blocks)。

            次は、**Checkpoint Sync**を有効または無効にするオプションです。

            <img src={tuiLocalCheckpoint} width="100%" height="auto"/>

            Lighthouseには、信頼できる既存のBeacon Nodeに接続することで、Beacon Chainネットワークの最新ブロックに即座に同期する機能があります。
            これは従来の同期よりも好まれます。時間がかからない（従来の同期には数日かかる可能性があります）ため、いくつかのセキュリティ上の利点もあります。
            詳しく知りたい場合は、[チェックポイント同期に関する彼らのドキュメント](https://lighthouse-book.sigmaprime.io/checkpoint-sync.html)をご覧ください。

            REST APIへのアクセスを提供する任意のBeacon NodeのURLをここに入力できます。

            使用したい場合は、[以下のCheckpoint Syncingに関するセクション](#beacon-chain-checkpoint-syncing)をご覧ください。

            最後の質問は、Doppelgänger Protectionを有効にするかどうかを尋ねます。

            <img src={tuiLocalDD} width="100%" height="auto"/>

            Lighthouseは[Doppelgänger Detection](https://lighthouse-book.sigmaprime.io/validator-doppelganger.html)と呼ばれる機能をサポートしています。
            簡単に言えば、この機能はLighthouseのValidator Client再起動後に**意図的に**いくつかのアテステーションをミスします。その間、バリデータキーを使用してアテステーションがネットワークに送信されているかどうかを監視します。

            理想的には、アテステーションはありません（つまり、他のマシンがバリデータキーを添付して実行していないことを意味します）。
            短い待機期間の後、Lighthouseは通常どおり検証を開始します。

            _ただし_、バリデータキーを添付して実行している他のマシンが_ある_場合、Lighthouseは即座にシャットダウンし、ログファイルにエラーメッセージを発行します。
            これは、アテステーションも開始すると、**二重アテステーション**が発生し、これは**スラッシュ可能な違反**だからです。
            スラッシュされると、バリデータはBeacon Chainから強制的に退出され、大量のETHがペナルティとして課されます。

            ほとんどの場合、doppelgänger detectionは、クライアント再起動後のいくつかのアテステーションのミス以外には何も生じません。
            ただし、バリデータを新しいマシンに移動している場合や新しいBeaconクライアントに変更している場合、**doppelgänger detectionは、誤って二重アテステーションしてスラッシュされるのを防ぐことができます**。

            ミニプールの安価な保険と考えてください。再起動するたびにわずかな利益をミスしますが、キーを2か所で実行してスラッシュされることがないとかなり確信できます。

            バージョン4.5.0以降、Lighthouseには[QUICプロトコル](https://en.wikipedia.org/wiki/QUIC)を使用してより効率的な方法でP2P接続を確立するオプションがあります。この機能を使用する場合は、ETH2設定で追加のポート「P2P QUICポート」フィールドを定義し、ルーターのポート転送設定でノードに転送する必要があります。デフォルトのP2P QUICポートは8001（UDP）です。ノード（またはフォールバック/テストネットノード）で既に使用されているポートとの競合を避けてください。また、ノードでファイアウォールを使用している場合は、同じポートが開いていることを確認してください（`ufw status`を確認してください）。
            QUIC設定が機能しているかどうかを確認するには、`docker run --network rocketpool_net curlimages/curl http://eth2:9100/metrics | grep libp2p_peers_multi`を実行したときに`libp2p_quic_peers`の後に2桁の数字が表示されるはずです。

          </Tab>
          <Tab label="Nimbus">
            Nimbusの設定の最初のオプションは、バリデータの**graffiti**メッセージについて尋ねます。

            <img src={tuiLocalGraffiti} width="100%" height="auto"/>

            これは、Beacon Chainで提案するブロックに添付できるオプションのカスタムメッセージです。
            メッセージは永遠に保存されるので、自分の痕跡を残す楽しい小さな方法と考えてください。

            **graffitiの最大長は16文字です。**

            今日バリデータがGraffitiに何を使用しているかの例を見たい場合は、[こちらをご覧ください](https://beaconcha.in/blocks)。

            次は、**Checkpoint Sync**を有効または無効にするオプションです。

            <img src={tuiLocalCheckpoint} width="100%" height="auto"/>

            Nimbusには、信頼できる既存のBeacon Nodeに接続することで、Beacon Chainネットワークの最新ブロックに即座に同期する機能があります。
            これは従来の同期よりも好まれます。時間がかからない（従来の同期には数日かかる可能性があります）ため、いくつかのセキュリティ上の利点もあります。
            詳しく知りたい場合は、[チェックポイント同期に関する彼らのドキュメント](https://nimbus.guide/trusted-node-sync.html)をご覧ください。

            REST APIへのアクセスを提供する任意のBeacon NodeのURLをここに入力できます。

            使用したい場合は、[以下のCheckpoint Syncingに関するセクション](#beacon-chain-checkpoint-syncing)をご覧ください。

            最後の質問は、Doppelgänger Protectionを有効にするかどうかを尋ねます。

            <img src={tuiLocalDD} width="100%" height="auto"/>

            Nimbusは[Doppelgänger Protection](https://nimbus.guide/faq.html#why-does-my-validator-miss-two-epochs-of-attestations-after-restarting)と呼ばれる機能をサポートしています。
            簡単に言えば、この機能はNimbus再起動後に**意図的に**いくつかのアテステーションをミスします。その間、バリデータキーを使用してアテステーションがネットワークに送信されているかどうかを監視します。

            理想的には、アテステーションはありません（つまり、他のマシンがバリデータキーを添付して実行していないことを意味します）。
            短い待機期間の後、Nimbusは通常どおり検証を開始します。

            _ただし_、バリデータキーを添付して実行している他のマシンが_ある_場合、Nimbusは即座にシャットダウンし、ログファイルにエラーメッセージを発行します。
            これは、アテステーションも開始すると、**二重アテステーション**が発生し、これは**スラッシュ可能な違反**だからです。
            スラッシュされると、バリデータはBeacon Chainから強制的に退出され、大量のETHがペナルティとして課されます。

            ほとんどの場合、doppelgänger detectionは、クライアント再起動後のいくつかのアテステーションのミス以外には何も生じません。
            ただし、バリデータを新しいマシンに移動している場合や新しいBeaconクライアントに変更している場合、**doppelgänger detectionは、誤って二重アテステーションしてスラッシュされるのを防ぐことができます**。

            ミニプールの安価な保険と考えてください。再起動するたびにわずかな利益をミスしますが、キーを2か所で実行してスラッシュされることがないとかなり確信できます。

          </Tab>
          <Tab label="Prysm">
            Prysmの設定の最初のオプションは、バリデータの**graffiti**メッセージについて尋ねます。

            <img src={tuiLocalGraffiti} width="100%" height="auto"/>

            これは、Beacon Chainで提案するブロックに添付できるオプションのカスタムメッセージです。
            メッセージは永遠に保存されるので、自分の痕跡を残す楽しい小さな方法と考えてください。

            **graffitiの最大長は16文字です。**

            今日バリデータがGraffitiに何を使用しているかの例を見たい場合は、[こちらをご覧ください](https://beaconcha.in/blocks)。

            次は、**Checkpoint Sync**を有効または無効にするオプションです。

            <img src={tuiLocalCheckpoint} width="100%" height="auto"/>

            Prysmには、信頼できる既存のBeacon Nodeに接続することで、Beacon Chainネットワークの最新ブロックに即座に同期する機能があります。
            これは従来の同期よりも好まれます。時間がかからない（従来の同期には数日かかる可能性があります）ため、いくつかのセキュリティ上の利点もあります。
            詳しく知りたい場合は、[チェックポイント同期に関する彼らのドキュメント](https://docs.prylabs.network/docs/prysm-usage/checkpoint-sync)をご覧ください。

            REST APIへのアクセスを提供する任意のBeacon NodeのURLをここに入力できます。

            使用したい場合は、[以下のCheckpoint Syncingに関するセクション](#beacon-chain-checkpoint-syncing)をご覧ください。

            最後の質問は、Doppelgänger Protectionを有効にするかどうかを尋ねます。

            <img src={tuiLocalDD} width="100%" height="auto"/>

            PrysmはDoppelgänger Protectionと呼ばれる機能をサポートしています。
            簡単に言えば、この機能はPrysmのValidator Client再起動後に**意図的に**いくつかのアテステーションをミスします。その間、バリデータキーを使用してアテステーションがネットワークに送信されているかどうかを監視します。

            理想的には、アテステーションはありません（つまり、他のマシンがバリデータキーを添付して実行していないことを意味します）。
            短い待機期間の後、Prysmは通常どおり検証を開始します。

            _ただし_、バリデータキーを添付して実行している他のマシンが_ある_場合、Prysmは即座にシャットダウンし、ログファイルにエラーメッセージを発行します。
            これは、アテステーションも開始すると、**二重アテステーション**が発生し、これは**スラッシュ可能な違反**だからです。
            スラッシュされると、バリデータはBeacon Chainから強制的に退出され、大量のETHがペナルティとして課されます。

            ほとんどの場合、doppelgänger detectionは、クライアント再起動後のいくつかのアテステーションのミス以外には何も生じません。
            ただし、バリデータを新しいマシンに移動している場合や新しいBeaconクライアントに変更している場合、**doppelgänger detectionは、誤って二重アテステーションしてスラッシュされるのを防ぐことができます**。

            ミニプールの安価な保険と考えてください。再起動するたびにわずかな利益をミスしますが、キーを2か所で実行してスラッシュされることがないとかなり確信できます。

          </Tab>
          <Tab label="Teku">
            Tekuの設定の最初のオプションは、バリデータの**graffiti**メッセージについて尋ねます。

            <img src={tuiLocalGraffiti} width="100%" height="auto"/>

            これは、Beacon Chainで提案するブロックに添付できるオプションのカスタムメッセージです。
            メッセージは永遠に保存されるので、自分の痕跡を残す楽しい小さな方法と考えてください。

            **graffitiの最大長は16文字です。**

            今日バリデータがGraffitiに何を使用しているかの例を見たい場合は、[こちらをご覧ください](https://beaconcha.in/blocks)。

            最後の質問は、**Checkpoint Sync**を有効または無効にするオプションです。

            <img src={tuiLocalCheckpoint} width="100%" height="auto"/>

            Tekuには、信頼できる既存のBeacon Nodeに接続することで、Beacon Chainネットワークの最新ブロックに即座に同期する機能があります。
            これは従来の同期よりも好まれます。時間がかからない（従来の同期には数日かかる可能性があります）ため、いくつかのセキュリティ上の利点もあります。
            詳しく知りたい場合は、[チェックポイント同期に関する彼らのドキュメント](https://docs.teku.consensys.net/en/latest/HowTo/Get-Started/Checkpoint-Start/)をご覧ください。

            REST APIへのアクセスを提供する任意のBeacon NodeのURLをここに入力できます。

            使用したい場合は、[以下のCheckpoint Syncingに関するセクション](#beacon-chain-checkpoint-syncing)をご覧ください。
          </Tab>
          <Tab label="Lodestar">
            Lodestarの設定の最初のオプションは、バリデータの**graffiti**メッセージについて尋ねます。

            <img src={tuiLocalGraffiti} width="100%" height="auto"/>

            これは、Beacon Chainで提案するブロックに添付できるオプションのカスタムメッセージです。
            メッセージは永遠に保存されるので、自分の痕跡を残す楽しい小さな方法と考えてください。

            **graffitiの最大長は16文字です。**

            今日バリデータがGraffitiに何を使用しているかの例を見たい場合は、[こちらをご覧ください](https://beaconcha.in/blocks)。

            次は、**Checkpoint Sync**を有効または無効にするオプションです。

            <img src={tuiLocalCheckpoint} width="100%" height="auto"/>

            Lodestarには、信頼できる既存のBeacon Nodeに接続することで、Beacon Chainネットワークの最新ブロックに即座に同期する機能があります。
            これは従来の同期よりも好まれます。時間がかからない（従来の同期には数日かかる可能性があります）ため、いくつかのセキュリティ上の利点もあります。
            詳しく知りたい場合は、[チェックポイント同期に関する彼らのドキュメント](https://chainsafe.github.io/lodestar/run/beacon-management/starting-a-node#checkpoint-sync)をご覧ください。

            REST APIへのアクセスを提供する任意のBeacon NodeのURLをここに入力できます。

            使用したい場合は、[以下のCheckpoint Syncingに関するセクション](#beacon-chain-checkpoint-syncing)をご覧ください。

            最後の質問は、Doppelgänger Protectionを有効にするかどうかを尋ねます。

            <img src={tuiLocalDD} width="100%" height="auto"/>

            LodestarはDoppelgänger Detectionと呼ばれる機能をサポートしています。
            簡単に言えば、この機能はLodestarのValidator Client再起動後に**意図的に**いくつかのアテステーションをミスします。その間、バリデータキーを使用してアテステーションがネットワークに送信されているかどうかを監視します。

            理想的には、アテステーションはありません（つまり、他のマシンがバリデータキーを添付して実行していないことを意味します）。
            短い待機期間の後、Lodestarは通常どおり検証を開始します。

            _ただし_、バリデータキーを添付して実行している他のマシンが_ある_場合、Lodestarは即座にシャットダウンし、ログファイルにエラーメッセージを発行します。
            これは、アテステーションも開始すると、**二重アテステーション**が発生し、これは**スラッシュ可能な違反**だからです。
            スラッシュされると、バリデータはBeacon Chainから強制的に退出され、大量のETHがペナルティとして課されます。

            ほとんどの場合、doppelgänger detectionは、クライアント再起動後のいくつかのアテステーションのミス以外には何も生じません。
            ただし、バリデータを新しいマシンに移動している場合や新しいBeaconクライアントに変更している場合、**doppelgänger detectionは、誤って二重アテステーションしてスラッシュされるのを防ぐことができます**。

            ミニプールの安価な保険と考えてください。再起動するたびにわずかな利益をミスしますが、キーを2か所で実行してスラッシュされることがないとかなり確信できます。

          </Tab>
        </Tabs>
      </div>

      <p className="rspress-directive warning">
        <p className="rspress-directive-title">注意</p>
        **ルーターのポート転送設定でP2Pポートを開いてください**。**ポート9001**のTCPとUDPの両方をマシンのローカルIPアドレスに転送するように設定します。
        これにより、他のConsensusクライアントがそれを発見し、外部から通信できるようになります。これにより、Consensusクライアントが迅速に同期し、パフォーマンス（したがって報酬）が向上します。

        各ルーターには異なる方法があるため、**ポート転送の設定方法については、ルーターのマニュアルを確認する必要があります**
      </p>
    </Tab>
    <Tab label="Externally Managed">
      各Consensusクライアントの動作は若干異なるため、Smartnodeは外部で使用しているクライアントを知る必要があり、それに応じて自身の動作を適応させることができます。
      次の画面のリストから使用しているクライアントを選択することから始めます。

      <img src="./images/tui-external-cc.png" width="100%" height="auto"/>


      <p className="rspress-directive warning">
        <p className="rspress-directive-title">注意</p>
        現時点では、**Nimbus**はスタンドアロンのValidator Container（VC）としてまだ実行できないため、Externalモードと互換性がありません。
        クライアントがこの機能をサポートすると、ここのリストに追加されます。
      </p>

      以下のタブからクライアントを選択して、設定を完了する方法を学んでください。

      <div className="p-3">
        <Tabs>
          <Tab label="Lighthouse">
            まず、Lighthouse Beacon NodeのAPIのURLを指定します。

            <img src={tuiExternalLH} width="100%" height="auto"/>

            Smartnodeは、HTTP URLを使用して通信し、チェーンの状態のクエリやメッセージの送信などのブロックチェーンアクティビティを実行します。
            **まだAPIポートを有効にしてSmartnodeマシンからアクセスできるようにしていない場合は、今すぐ設定する必要があります。**
            これを行う方法については、[Lighthouseのドキュメント](https://lighthouse-book.sigmaprime.io/api-bn.html)を参照してください。

            <p className="rspress-directive warning">
              <p className="rspress-directive-title">注意</p>
              Smartnodeは独自のDockerコンテナで実行されるため、Dockerの内部ネットワークを使用します。
              ここでは`localhost`や`127.0.0.1`のようなホスト名を使用できません。クライアントがSmartnodeと同じマシンで実行されている場合は、代わりにマシンのLAN IPアドレスを提供する必要があります。
            </p>


            次に、バリデータの**graffiti**メッセージについて尋ねます。

            <img src={tuiExternalGraffiti} width="100%" height="auto"/>

            これは、Beacon Chainで提案するブロックに添付できるオプションのカスタムメッセージです。
            メッセージは永遠に保存されるので、自分の痕跡を残す楽しい小さな方法と考えてください。

            **graffitiの最大長は16文字です。**

            今日バリデータがGraffitiに何を使用しているかの例を見たい場合は、[こちらをご覧ください](https://beaconcha.in/blocks)。

            最後の質問は、Doppelgänger Protectionを有効にするかどうかを尋ねます。

            <img src={tuiExternalDD} width="100%" height="auto"/>

            Lighthouseは[Doppelgänger Detection](https://lighthouse-book.sigmaprime.io/validator-doppelganger.html)と呼ばれる機能をサポートしています。
            簡単に言えば、この機能はLighthouseのValidator Client再起動後に**意図的に**いくつかのアテステーションをミスします。その間、バリデータキーを使用してアテステーションがネットワークに送信されているかどうかを監視します。

            理想的には、アテステーションはありません（つまり、他のマシンがバリデータキーを添付して実行していないことを意味します）。
            短い待機期間の後、Lighthouseは通常どおり検証を開始します。

            _ただし_、バリデータキーを添付して実行している他のマシンが_ある_場合、Lighthouseは即座にシャットダウンし、ログファイルにエラーメッセージを発行します。
            これは、アテステーションも開始すると、**二重アテステーション**が発生し、これは**スラッシュ可能な違反**だからです。
            スラッシュされると、バリデータはBeacon Chainから強制的に退出され、大量のETHがペナルティとして課されます。

            ほとんどの場合、doppelgänger detectionは、クライアント再起動後のいくつかのアテステーションのミス以外には何も生じません。
            ただし、バリデータを新しいマシンに移動している場合や新しいBeaconクライアントに変更している場合、**doppelgänger detectionは、誤って二重アテステーションしてスラッシュされるのを防ぐことができます**。

            ミニプールの安価な保険と考えてください。再起動するたびにわずかな利益をミスしますが、キーを2か所で実行してスラッシュされることがないとかなり確信できます。

          </Tab>
          <Tab label="Prysm">
            まず、Prysm Beacon NodeのAPIのURLとJSON-RPC APIのURLを指定します。

            <img src={tuiExternalPrysm} width="100%" height="auto"/>

            Smartnodeは、HTTP URLを使用して通信し、チェーンの状態のクエリやメッセージの送信などのブロックチェーンアクティビティを実行します。
            JSON-RPC URLでPrysm Validator Clientを準備し、Beacon Nodeと通信できるようにします。_PrysmのValidator ClientはHTTP APIを介して動作できないためです。_

            **まだAPIポートを有効にしてSmartnodeマシンからアクセスできるようにしていない場合は、今すぐ設定する必要があります。**
            これを行う方法については、[Prysmのドキュメント](https://docs.prylabs.network/docs/prysm-usage/parameters)を参照してください。
            **`grpc-gateway`_および_`rpc-host`を有効にする必要があります。**

            <p className="rspress-directive warning">
              <p className="rspress-directive-title">注意</p>
              Smartnodeは独自のDockerコンテナで実行されるため、Dockerの内部ネットワークを使用します。
              ここでは`localhost`や`127.0.0.1`のようなホスト名を使用できません。クライアントがSmartnodeと同じマシンで実行されている場合は、代わりにマシンのLAN IPアドレスを提供する必要があります。
            </p>


            次に、バリデータの**graffiti**メッセージについて尋ねます。

            <img src={tuiExternalGraffiti} width="100%" height="auto"/>

            これは、Beacon Chainで提案するブロックに添付できるオプションのカスタムメッセージです。
            メッセージは永遠に保存されるので、自分の痕跡を残す楽しい小さな方法と考えてください。

            **graffitiの最大長は16文字です。**

            今日バリデータがGraffitiに何を使用しているかの例を見たい場合は、[こちらをご覧ください](https://beaconcha.in/blocks)。

            最後の質問は、Doppelgänger Protectionを有効にするかどうかを尋ねます。

            <img src={tuiExternalDD} width="100%" height="auto"/>

            PrysmはDoppelgänger Protectionと呼ばれる機能をサポートしています。
            簡単に言えば、この機能はPrysmのValidator Client再起動後に**意図的に**いくつかのアテステーションをミスします。その間、バリデータキーを使用してアテステーションがネットワークに送信されているかどうかを監視します。

            理想的には、アテステーションはありません（つまり、他のマシンがバリデータキーを添付して実行していないことを意味します）。
            短い待機期間の後、Prysmは通常どおり検証を開始します。

            _ただし_、バリデータキーを添付して実行している他のマシンが_ある_場合、Prysmは即座にシャットダウンし、ログファイルにエラーメッセージを発行します。
            これは、アテステーションも開始すると、**二重アテステーション**が発生し、これは**スラッシュ可能な違反**だからです。
            スラッシュされると、バリデータはBeacon Chainから強制的に退出され、大量のETHがペナルティとして課されます。

            ほとんどの場合、doppelgänger detectionは、クライアント再起動後のいくつかのアテステーションのミス以外には何も生じません。
            ただし、バリデータを新しいマシンに移動している場合や新しいBeaconクライアントに変更している場合、**doppelgänger detectionは、誤って二重アテステーションしてスラッシュされるのを防ぐことができます**。

            ミニプールの安価な保険と考えてください。再起動するたびにわずかな利益をミスしますが、キーを2か所で実行してスラッシュされることがないとかなり確信できます。

          </Tab>
          <Tab label="Teku">
            まず、Teku Beacon NodeのAPIのURLを指定します。

            <img src={tuiExternalTeku} width="100%" height="auto"/>

            Smartnodeは、HTTP URLを使用して通信し、チェーンの状態のクエリやメッセージの送信などのブロックチェーンアクティビティを実行します。
            **まだAPIポートを有効にしてSmartnodeマシンからアクセスできるようにしていない場合は、今すぐ設定する必要があります。**
            これを行う方法については、[Tekuのドキュメント](https://docs.teku.consensys.net/en/latest/Reference/CLI/CLI-Syntax/#rest-api-enabled)を参照してください。


            <p className="rspress-directive warning">
              <p className="rspress-directive-title">注意</p>
              Smartnodeは独自のDockerコンテナで実行されるため、Dockerの内部ネットワークを使用します。
              ここでは`localhost`や`127.0.0.1`のようなホスト名を使用できません。クライアントがSmartnodeと同じマシンで実行されている場合は、代わりにマシンのLAN IPアドレスを提供する必要があります。
            </p>

            次に、バリデータの**graffiti**メッセージについて尋ねます。

            <img src={tuiExternalGraffiti} width="100%" height="auto"/>

            これは、Beacon Chainで提案するブロックに添付できるオプションのカスタムメッセージです。
            メッセージは永遠に保存されるので、自分の痕跡を残す楽しい小さな方法と考えてください。

            **graffitiの最大長は16文字です。**

            今日バリデータがGraffitiに何を使用しているかの例を見たい場合は、[こちらをご覧ください](https://beaconcha.in/blocks)。
          </Tab>

        </Tabs>
      </div>
    </Tab>

  </Tabs>
</div>

#### Beacon Chainチェックポイント同期

**チェックポイント同期**は、一部のBeacon Chainクライアントがサポートする非常に有用な技術です。
これにより、Beaconクライアントは、最初から開始してすべてのブロックをキャッチアップすることなく、Beacon Chain全体を即座に同期できます。
これは、**数日**かかる代わりに、Beaconクライアントが**数分**で準備できることを意味します。
必要なのは、信頼できる既存のBeaconクライアントへのアクセスだけです。

HTTP APIへのアクセスを提供する任意のBeacon Nodeを使用できます。
現在、多くのノードオペレーターはcheckpoint-sync-endpointsを使用しています。これは、Rocket Poolノードオペレーターが簡単にチェックポイント同期できるようにするサービスです。
Hoodi TestnetとMainnetの両方がサポートされています。
チェックポイント同期URLのリストは、次のリンクから見つけることができます。

- [チェックポイント同期URL](https://eth-clients.github.io/checkpoint-sync-endpoints/)

関連するチェックポイント同期URLを選択し、Checkpoint Sync Providerの入力を求められたときに`rocketpool service config`中にターミナルに貼り付けます。

その後、Beacon Nodeは最初に起動したときにチェックポイント同期ノードに自動的に接続し、チェーンの最新の状態を即座にプルダウンします。

::: warning 注意
チェックポイント同期は、*まだBeacon Chainデータがない*場合にのみ発生します。
言い換えれば、通常の同期を開始してから後でチェックポイント同期を決定した場合、チェックポイント同期が機能するためには、最初にチェーンデータを削除する必要があります。
これは次のコマンドで簡単に実行できます。

```shell
rocketpool service resync-eth2
```

:::

### フォールバックノード

Smartnodeスタックの1.5.0以降、プライマリクライアントがオフラインになった場合（Gethを使用していてプルーニングする必要がある場合など）に引き継ぐことができる「フォールバック」ExecutionクライアントとConsensusクライアントのペアを提供できます。
この状況では、プライマリノードマシンは、ミニプールのバリデータキーでアテステーションとブロック提案を行う責任を引き続き負いますが、Execution層とBeacon Chainと対話するために外部マシンに接続します。

[フォールバックノードの詳細については、このセクションを参照してください](./fallback)。完了したらここに戻ってください。

### メトリクス設定

Rocket Poolには、ノードのハードウェアの健全性、システムアップデート、バリデータのパフォーマンス、報酬、Rocket Poolネットワーク全体に関する情報などを示す詳細なダッシュボードを表示する機能が付属しています。

<img src="./images/nimbus-dashboard.png" width="100%" height="auto" />

ウィザードの次の質問では、これを有効にするかどうかを尋ねます。

<img src="./images/tui-metrics.png" width="100%" height="auto" />

有効にすることを選択した場合、プロセスの後半の[Grafanaダッシュボードの設定](./grafana)セクションで、設定方法と使用方法について詳しく学びます。

::: warning 注意
このシステムによって収集されるすべてのデータは**マシンに残ります**。
Rocket Poolはテレメトリを収集したり、別のサービスに送信したりしません。
これは純粋に、自分のノードを監視できるようにするためのものです。
:::

### MEV設定

2022年9月のExecution層とConsensus層のMerge以降、Ethereumバリデータは優先手数料を獲得し、Maximal Extractable Value（略してMEV）に参加する能力を持つようになりました。

Smartnode v1.7.0以降、MEVは*オプトアウト*になったため、初期設定の一部として構成が提示されます。次の画面に表示されます。

<img src="./images/tui-mev-mode.png" width="100%" height="auto" />

[MEVの詳細、設定、およびウィザードのこのセクションで何をすべきかについては、MEVガイドをお読みください。](./mev)
完了したらここに戻ってください。

### 完了

この質問の後、Smartnodeの設定が完了しました。
次のダイアログが表示されます。

<img src="./images/tui-finished.png" width="100%" height="auto" />

セットアップに満足していてSmartnodeを開始する準備ができている場合は、ここで`Save and Exit`をクリックして、次に[ノードの保護](./securing-your-node)セクションに進んでください。

すべての設定を確認し、ウィザードに含まれていない多くの追加設定をカスタマイズしたい場合は、`Review All Settings`をクリックして、[次のセクション](#設定マネージャーによる設定)に進んでください。

## 設定マネージャーによる設定

すでに`rocketpool service config`を実行している場合、ウィザードではなく、**設定マネージャー**画面が表示されます。

<img src="./images/tui-settings-manager.png" width="100%" height="auto" />

この画面には3つの主な機能があります。

1. **カテゴリリスト**。Smartnodeスタックの各カテゴリの設定にドリルダウンできます
2. **Review Changes and Save**ボタン。変更した設定を確認して更新された設定を保存する準備ができたときに使用できます
3. **Open the Config Wizard**ボタン。代わりにそのインターフェイスを希望する場合は、[セットアップウィザード](#ウィザードによる設定)に移動します

::: tip ヒント
設定マネージャーを使用するには、**`矢印キー`（上/下/左/右）を押して、ホームページのオプション間を移動します**。

`Tab`を押して**カテゴリリスト（1）と画面下部のボタン（2および3）の間を移動します**。
現在選択されているボタンは**緑色でハイライト表示されます**。

**`Enter`または`Space`を押してボタンを選択します**。これはマウスでクリックするのと同じです。

**いつでも`Ctrl`を押しながら`C`を押すと、何も保存せずに設定マネージャーを終了できます**。
:::

カテゴリリストをスクロールすると、各オプションは画面の右側の**説明ボックス**に役立つ説明が表示されます。
自由に探索してください。Reviewダイアログを介して**Review Changes and Save**ボタンを使用するまで何も保存されず、いつでも**Ctrl+C**を押して保存せずに終了できるため、ここで設定をいじって誤って何かを台無しにすることはありません。

### 設定の構成

ホーム画面から、`Enter`キーを使用して任意のカテゴリを選択し、そのカテゴリの設定を表示します。
たとえば、これは**Smartnode and TX Fees**カテゴリの画面です。

<img src="./images/tui-smartnode.png" width="100%" height="auto" />

`矢印キー`を使用して設定を上下に移動します。
現在選択されているものには、末尾に白い四角形があります（テキストボックスまたはチェックボックスの場合）、または白でハイライト表示されます（ドロップダウンの場合）。

終了したら、`Escape`を押して設定マネージャーのホーム画面に戻ります。

設定をスクロールすると、各設定は右側の**説明ボックス**に何をするかの簡単な説明が表示されます。
また、ストック設定に戻したい場合に備えて、**デフォルト値**も表示されます。

この例では、**RPL Claim Gas Threshold**設定が現在選択されています（左側の画面で緑色のボックスでハイライト表示されています）。
`40`に変更されていますが、右上隅（**説明ボックス**の上部）に`150`のデフォルトがあることがわかります。

::: tip ヒント
思い出してください。**Review Changes and Save**ボタンを介してReviewダイアログを通過するまで、何もディスクに保存されません。
すべての設定を探索して、Smartnodeができることを学ぶことをお勧めします。
:::

### 設定タイプとその使用方法

設定マネージャーは、次の設定タイプとUI要素を使用します。

#### テキストボックス

テキストボックスは、任意のテキストまたは数字の文字列を入力するために使用されます。
次のように見えます。

<img src="./images/tui-textbox.png" width="100%" height="auto" />

希望する値を入力してから、**`Enter`を押すか、`矢印キー`を使用して別の設定に移動して変更を保持します。**
そうしないと、設定マネージャーはまだその設定を更新していると想定し、まだ変更としてマークしません。

#### ドロップダウン

ドロップダウンは、選択肢のリストからオプションを選択するために使用されます。
次のように見えます（開いている場合）。

<img src="./images/tui-dropdown-open.png" width="100%" height="auto" />

**緑色**の項目が現在選択されているものです。
`矢印キー`を使用してオプションを変更します。変更すると、右側の**説明ボックス**が更新され、現在選択されているオプションについて詳しく説明します。
選択に満足したら、`Enter`を押して選択したオプションを選択すると、ドロップダウンが閉じ、現在選択されているオプションが表示されます。

<img src="./images/tui-dropdown-closed.png" width="100%" height="auto" />

#### チェックボックス

チェックボックスは、単純なYes/Noの質問に使用されます。
次のように見えます。

<img src="./images/tui-checkbox-checked.png" width="100%" height="auto" />

チェックされている場合、上記のように中央に`X`があります。
*チェックされていない*場合、次のように単に空白になります。

<img src="./images/tui-checkbox-unchecked.png" width="100%" height="auto" />

設定を変更するには、単に選択して`Enter`を押します。

### 変更の保存

変更に満足していて、保存する前に確認したい場合は、ホーム画面の**Review Changes and Save**ボタンを押します。
思い出してください。それにアクセスするには、`Tab`キーを押します。

次のようなビューが表示されます。

<img src="./images/tui-review.png" width="100%" height="auto" />

ここの**Reviewボックス**には、変更したすべての設定が表示され、古い値と新しい値が表示されます。
たとえば、ここの最初の行は、**RPL Claim Gas Threshold**が`150`であったことを示し、`40`に変更されました。

また、変更した設定によって影響を受けるコンテナも表示され、変更を保存した後にそれらを再起動するように提案されます。

::: tip 注意
この時点では、変更は**まだ保存されていません**。
何かを戻して変更したい場合は、`Escape`を押してホーム画面に戻ります。
:::

変更に満足したら、`Enter`を押して新しい設定をディスクに保存します。
その後、ターミナルUIを終了し、次のようなメッセージが表示されます。

```
Your changes have been saved!
The following containers must be restarted for the changes to take effect:
	rocketpool_watchtower
	rocketpool_validator
	rocketpool_eth2
	rocketpool_node
Would you like to restart them automatically now? [y/n]
```

新しい設定変更を自動的に適用して、影響を受けるコンテナを再起動する場合は、`y`と`Enter`を押します。

再起動する前に他にやりたいことがあり、後で手動で行う場合は、`n`と`Enter`を押します。

いずれの場合も、設定は完了です。

::: tip 注意
次のようなエラーメッセージが表示される場合があります。

```
2022/08/13 13:49:41 Error piping stdout: read |0: file already closed
```

これは実際にはエラーではなく、単なる表面的な不具合です。
安全に無視できます。
:::

::: tip 注意
Mac OSを実行している場合、node_exporterに関する問題が表示される場合があります。
修正するには、これらのコマンドを実行する必要があります。

```shell
rocketpool service stop
nano ~/.rocketpool/override/exporter.yml
```

ファイルの内容全体を次のように置き換えます。

```
# Enter your own customizations for the node exporter container here. These changes will persist after upgrades, so you only need to do them once.
#
# See https://docs.docker.com/compose/extends/#adding-and-overriding-configuration
# for more information on overriding specific parameters of docker-compose files.

version: "3.7"
services:
  node-exporter:
    x-rp-comment: Add your customizations below this line
    volumes:   ["/proc:/host/proc:ro","/sys:/host/sys:ro"]
```

最後に`rocketpool service start`を実行します。
:::

## コマンドラインによる設定

ターミナルUIと対話できないヘッドレス環境でSmartnodeを使用する場合は、代わりにコマンドラインでノードを設定できます。

`rocketpool service config`コマンドは、引数として、通常ターミナルUI経由で設定できるすべての設定を受け入れます。
次のコマンドを実行して、それらのリストを表示します（非常に長いことに注意してください）。

```shell
rocketpool service config --help
```

出力は次のようになります。

```
NAME:
   rocketpool service config - Configure the Rocket Pool service

USAGE:
   rocketpool service config

OPTIONS:
   --executionClientMode value  Choose which mode to use for your Execution client - locally managed (Docker Mode), or externally managed (Hybrid Mode).
                                Type: choice
                                Options: local, external
 (default: "local")
   --executionClient value  Select which Execution client you would like to run.
                            Type: choice
                            Options: geth, infura, pocket
 (default: "geth")
   --useFallbackExecutionClient         Enable this if you would like to specify a fallback Execution client, which will temporarily be used by the Smartnode and your Consensus client if your primary Execution client ever goes offline.
                                        Type: bool

...
```

各オプションには、名前、タイプ、デフォルト値、および（choiceパラメータの場合）オプションがあります。
このテキストを使用して、設定したいオプションを見つけて、適切な引数を介して指定できます。

::: tip 注意
このコマンドは既存の設定の上に構築されるため、すでにいくつかの設定を保存していて他の設定を変更したいだけの場合は、それらを繰り返す必要はありません。
このコマンドに引数として含める設定のみを更新します。
:::

## 次のステップ

ノードを好みどおりに設定したら、オペレーティングシステムを保護してノードを保護する準備ができています。
次に[ノードの保護](./securing-your-node)セクションに進んでください。
